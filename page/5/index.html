<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Tomorrow will be better">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder Paradise">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Coder Paradise">
<meta property="og:description" content="Tomorrow will be better">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder Paradise">
<meta name="twitter:description" content="Tomorrow will be better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Coder Paradise</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder Paradise</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I am coding, I am happy.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Mybatis学习笔记——Mybatis框架简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/Mybatis学习笔记——Mybatis框架简介/" itemprop="url">Mybatis学习笔记——Mybatis框架简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T15:33:27+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Mybatis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Mybatis是什么"><a href="#Mybatis是什么" class="headerlink" title="Mybatis是什么"></a>Mybatis是什么</h4><p>Mybatis是apache下的顶级项目，让程序员将主要精力放在sql上，通过提供mybatis提供的映射方式，自动灵活的生成(半自动化，大部分需要程序员自己编写sql)满足需要的sql语句。可以将向perpareStatement中输入的参数自动进行输入映射，将查询的结果集灵活的映射成java对象(输出映射)。</p>
<h4 id="Mybatis框架的基础知识"><a href="#Mybatis框架的基础知识" class="headerlink" title="Mybatis框架的基础知识"></a>Mybatis框架的基础知识</h4><p>sqlMapConfig.xml:mybatis全局配置文件，配置数据源、事务等运行环境，配置映射文件mapper.xml(配置了sql语句)；<br>SqlSessionFactory:会话工厂，创建SqlSession；<br>SqlSession：会话，操作数据库(发出sql增、删、改、查)内部通过Executor操作数据库，mappedstatement(底层封装对象)，对数据库存储封装，包括sql语句，输入参数、输出结果类型；<br>mybatis中支持的输入参数类型(输出结果类型)：Java简单类型、hashmap、pojo自定义类型</p>
<h4 id="和-的区别与联系"><a href="#和-的区别与联系" class="headerlink" title="#{}和\${}的区别与联系"></a>#{}和\${}的区别与联系</h4><p>$#{} 表示占位符，接收输入参数，类型可以是简单类型、pojo、hashmap；如果为简单类型，#{}中可以写成value或其他名称，通过ONGL读取对象中的属性值；<br>$${}表示一个拼接符号，会引起sql注入所以不建议使用\${}，接收输入参数，类型可以为简单类型、pojo、hashmap；如果为简单类型${}只能写为value;</p>
<h4 id="OGNL简介"><a href="#OGNL简介" class="headerlink" title="OGNL简介"></a>OGNL简介</h4><p>OGNL的全称是Object Graph Navigation Language(对象图导航语言)，它是一种强大的表达式语言，让你通过简单一致的表达式语法来读取和设置Java对象的属性值，调用对象的方法，遍历整个对象的结构图，实现字段类型转换等功能。<br>相对于其它的表达式语言，OGNL的功能更为强大，它提供了很多高级而必需的特性，例如强大的类型转换功能、静态或实例方法的执行、跨集合投影，以及动态lambda表达式定义等。<br>OGNL基础：OGNL表达式的计算都是围绕OGNL上下文来进行的，OGNL上下文实际上就是一个Map对象，由ognl.OgnlContext类(实现了java.util.Map接口)来表示。OGNL上下文可以包含一个或多个JavaBean对象，在这些对象中有一个是特殊的，这个对象就是上下文的根(root)对象。如果在写表达式的时候，没有指定使用上下文中的哪一个对象，那么根对象将被假定为表达式所依据的对象。在OGNL上下文中，只能有一个根对象，如果你访问根对象，那么在写表达式的时候，直接写对象的属性就可以了；否则，你需要使用“#key”前缀，例如表达式#namager.name。<br>OGNL表达式:OGNL表达式的基础单元就是导航链，通常简称为链(chain)。最简单的链由下列部分组成：<br>１、属性名：如name和manager.name；</p>
<p>２、方法调用：如manager.hashCode()，返回manager对象的散列码；</p>
<p>３、数组索引：如emals[0]，返回当前对象的邮件列表中的第一个邮件地址。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Mybatis学习笔记——原生态JDBC的介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/Mybatis学习笔记——原生态JDBC的介绍/" itemprop="url">Mybatis学习笔记——原生态JDBC的介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T08:43:27+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Mybatis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h4><p>1.加载数据库驱动；</p>
<p>2.获得数据库连接；</p>
<p>3.创建Statment对象，执行sql语句；</p>
<p>4.设置sql语句；</p>
<p>5.执行sql语句，得到结果集；</p>
<p>6.对结果集进行分析处理；</p>
<p>7.释放资源；</p>
<h4 id="原生态JDBC存在如下问题："><a href="#原生态JDBC存在如下问题：" class="headerlink" title="原生态JDBC存在如下问题："></a>原生态JDBC存在如下问题：</h4><p>1.每一个连接的在使用时候创建，不用的时候需要释放，如果使用频繁的话，频繁的建立和释放连接会浪费系统的资源，影响数据库的性能；<strong>使用数据库连接池解决</strong></p>
<p>2.将sql语句硬编码到Java代码中，修改sql语句需要重新编译，不利于系统的维护；<strong>将sql语句配置在xml配置文件中，即使sql文件变化也不需要重新编译</strong></p>
<p>3.向PrepareStatment中设置参数，会对占位符位置和参数值硬编码，不利于系统的维护；；<strong>将sql语句配置在xml配置文件中，即使sql文件变化也不需要重新编译</strong></p>
<p>4.从result中遍历结果集数据时存在硬编码，主要体现在将获取字段进行硬编码不利于系统维护。<strong>将查询结果集自动映射为Java对象</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/20/Redis学习笔记——Redis哨兵模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/20/Redis学习笔记——Redis哨兵模式/" itemprop="url">Redis学习笔记——Redis哨兵模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-20T08:54:21+08:00">
                2018-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文转载自<a href="https://blog.csdn.net/weixin_42711549/article/details/83061052" target="_blank" rel="noopener">Redis Sentinel（哨兵）架构下的高可用</a></strong></p>
<h4 id="哨兵模式的简介"><a href="#哨兵模式的简介" class="headerlink" title="哨兵模式的简介"></a>哨兵模式的简介</h4><p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化通知给Redis应用方。整个过程完全是自动的，不需要人工来介入，所以这套方案很有效地解决了Redis的高可用问题。</p>
<h4 id="哨兵模式的作用"><a href="#哨兵模式的作用" class="headerlink" title="哨兵模式的作用"></a>哨兵模式的作用</h4><p>Redis的主从复制下，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址，对于很多应用场景这种故障处理的方法是无法接受的。但是Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现原理：</p>
<p>三个定时监控任务</p>
<p>1）每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。</p>
<p>2）每隔2秒，每个Sentinel节点会向Redis数据节点的<strong>sentinel</strong>:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。</p>
<p>3）每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点当前是否可达。</p>
<p>主观下线<br>因为每隔一秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</p>
<p>客观下线<br>当Sentinel主观下线的节点是主节点时，该Sentinel节点会向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，那么意味着大部分的Sentinel节点都对这个主节点的下线做了同意的判定，于是该Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。</quorum></p>
<p>领导者Sentinel节点选举<br>Raft算法：假设s1(sentinel-1)最先完成客观下线，它会向其余Sentinel节点发送命令，请求成为领导者；收到命令的Sentinel节点如果没有同意过其他Sentinel节点的请求，那么就会同意s1的请求，否则拒绝；如果s1发现自己的票数已经大于等于某个值，那么它将成为领导者。</p>
<p>故障转移<br>1）领导者Sentinel节点在从节点列表中选出一个节点作为新的主节点;</p>
<p>2）上一步的选取规则是与主节点复制相似度最高的从节点;</p>
<p>3）领导者Sentinel节点让剩余的从节点成为新的主节点的从节点;</p>
<p>4）Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/Redis学习笔记——Redis分布式锁实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/Redis学习笔记——Redis分布式锁实现/" itemprop="url">Redis学习笔记——Redis分布式锁实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-18T12:10:07+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为何会有分布式的锁"><a href="#为何会有分布式的锁" class="headerlink" title="为何会有分布式的锁"></a>为何会有分布式的锁</h4><p>我们知道，Reids和关系型数据库不同，他是单进程单线程的，他是不存在锁的说法的，那么我们为何又要提到锁呢？要知道我们这里讲的是分布式锁，也就是在分布式系统中，多个服务器(Tomcat)同时并发访问同一台Redis服务器(或者Mysql)上的相同的资源。由于Java中的syschornized和lock实现同步功能时候要求是在同一个jvm上，在分布式系统中，每个服务器上都有各自的jvm所以传统的锁很难发挥作用，但是不使用分布式锁就会出现问题。我们举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> N=<span class="number">0L</span>;</span><br><span class="line"><span class="comment">//N从redis获取值</span></span><br><span class="line"><span class="keyword">if</span>(N&lt;<span class="number">5</span>)&#123;</span><br><span class="line">N++；</span><br><span class="line"><span class="comment">//N写回redis</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码实现的功能是，对数值N进行边界检查，自加1，然后将结果写回到reids中，这种应用场景很常见，像秒杀，全局递增ID、IP访问限制等。以IP访问限制来说，恶意攻击者可能发起无限次访问，并发量比较大，分布式环境下对N的边界检查就不可靠，因为从redis读的N可能已经是脏数据。</p>
<h4 id="使用redis的setnx命令实现分布式锁"><a href="#使用redis的setnx命令实现分布式锁" class="headerlink" title="使用redis的setnx命令实现分布式锁"></a>使用redis的setnx命令实现分布式锁</h4><h5 id="1-实现的原理"><a href="#1-实现的原理" class="headerlink" title="1.实现的原理"></a>1.实现的原理</h5><p>redis是单进程单线程模式，采用队列模式将并发访问变为串行访问，且客户端对redis的连接也不存在竞争关系，所以redis的setnx命令很容易实现分布式锁的功能。</p>
<h5 id="2-基本命令解析"><a href="#2-基本命令解析" class="headerlink" title="2.基本命令解析"></a>2.基本命令解析</h5><p>(1)setnx（set if not exists）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx key1 v1 //将key1的值设置为v1,当v1不存在时，设置成功返回1.若key1已经存在则setnx不做任何动作返回0；</span><br></pre></td></tr></table></figure></p>
<p>2.getset指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset key1 v2   //将指定的key1的值设置为v2，并返回key1的旧值。当key1的旧值不存在(key1不存在)返回nil</span><br></pre></td></tr></table></figure></p>
<p>3.get指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key1   //当key不存在时，返回nil,否则返回key1的值若key1不是字符串类型则返回一个错误</span><br></pre></td></tr></table></figure></p>
<h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><p>我们将锁的超时时间设置为key所对应的value,首先进行setnx操作，如果返回true(设置成功)，则成功获得这个锁，反之则锁已经存在则需要通过get操作获得锁的值(到期时间)和当前时间进行比较，如果超时则重新设置该值。</p>
<h5 id="具体的代码"><a href="#具体的代码" class="headerlink" title="具体的代码"></a>具体的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 lock.</span></span><br><span class="line"><span class="comment">     * 实现思路: 主要是使用了redis 的setnx命令,缓存了锁.</span></span><br><span class="line"><span class="comment">     * reids缓存的key是锁的key,所有的共享, value是锁的到期时间(注意:这里把过期时间放在value了,没有时间上设置其超时时间)</span></span><br><span class="line"><span class="comment">     * 执行过程:</span></span><br><span class="line"><span class="comment">     * 1.通过setnx尝试设置某个key的值,成功(当前没有这个锁)则返回,成功获得锁</span></span><br><span class="line"><span class="comment">     * 2.锁已经存在则获取锁的到期时间,和当前时间比较,超时的话,则设置新的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if lock is acquired, false acquire timeouted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException in case of thread interruption</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeout = timeoutMsecs;</span><br><span class="line">        <span class="keyword">while</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> expires = System.currentTimeMillis() + expireMsecs + <span class="number">1</span>;</span><br><span class="line">            String expiresStr = String.valueOf(expires); <span class="comment">//锁到期时间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.setNX(lockKey, expiresStr)) &#123;</span><br><span class="line">                <span class="comment">// lock acquired</span></span><br><span class="line">                locked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String currentValueStr = <span class="keyword">this</span>.get(lockKey); <span class="comment">//redis里的时间</span></span><br><span class="line">            <span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                <span class="comment">//判断是否为空，不为空的情况下，如果被其他线程设置了值，则第二个条件判断是过不去的</span></span><br><span class="line">                <span class="comment">// lock is expired</span></span><br><span class="line"></span><br><span class="line">                String oldValueStr = <span class="keyword">this</span>.getSet(lockKey, expiresStr);</span><br><span class="line">                <span class="comment">//获取上一个锁到期时间，并设置现在的锁到期时间，</span></span><br><span class="line">                <span class="comment">//只有一个线程才能获取上一个线上的设置时间，因为jedis.getSet是同步的</span></span><br><span class="line">                <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">                    <span class="comment">//防止误删（覆盖，因为key是相同的）了他人的锁——这里达不到效果，这里值会被覆盖，但是因为什么相差了很少的时间，所以可以接受</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//[分布式的情况下]:如过这个时候，多个线程恰好都到了这里，但是只有一个线程的设置值和当前值相同，他才有权利获取锁</span></span><br><span class="line">                    <span class="comment">// lock acquired</span></span><br><span class="line">                    locked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeout -= DEFAULT_ACQUIRY_RESOLUTION_MILLIS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                延迟100 毫秒,  这里使用随机时间可能会好一点,可以防止饥饿进程的出现,即,当同时到达多个进程,</span></span><br><span class="line"><span class="comment">                只会有一个进程获得锁,其他的都用同样的频率进行尝试,后面有来了一些进行,也以同样的频率申请锁,这将可能导致前面来的锁得不到满足.</span></span><br><span class="line"><span class="comment">                使用随机的等待时间可以一定程度上保证公平性</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread.sleep(DEFAULT_ACQUIRY_RESOLUTION_MILLIS);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acqurired lock release.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (locked) &#123;</span><br><span class="line">            redisTemplate.delete(lockKey);</span><br><span class="line">            locked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h4><p>如果一个持有锁的客户端失败或崩溃了不能释放锁，是怎么解决的？<br>我们可以通过锁的键对应的时间戳来判断这种情况是否发生了，如果当前的时间已经大于锁的到期时间，说明该锁已失效，可以被重新使用。我们是通过指令getset方法进行处理的，如果c1超时了那么c2执行getset方法时，如果getset指令返回的是超时的值说明设置成功，成功的获取了锁，如果getset方法返回未超时时间则说明其他客户端比他快了一步，需要再次等待或者重试，留意一下，尽管C3没拿到锁，但它改写了C4设置的锁的超时值，不过这一点非常微小的误差带来的影响可以忽略不计。</p>
<h4 id="为何不用expire指令设置超时时间？"><a href="#为何不用expire指令设置超时时间？" class="headerlink" title="为何不用expire指令设置超时时间？"></a>为何不用expire指令设置超时时间？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock(key, expireSec)&#123;</span><br><span class="line">isSuccess = setnx key</span><br><span class="line">if (isSuccess)</span><br><span class="line">expire key expireSec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式貌似没什么问题，但是假如在setnx后，redis崩溃了，expire就没有执行，结果就是死锁了。锁永远不会超时。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="noopener">jedisLock—redis分布式锁实现</a><br><a href="https://blog.csdn.net/varyall/article/details/81205183" target="_blank" rel="noopener">10个常见的Redis面试”刁难”问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/Redis学习笔记——Redis主从复制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/Redis学习笔记——Redis主从复制/" itemprop="url">Redis学习笔记——Redis主从复制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-18T12:10:07+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要是摘录自Redis官方文档</p>
<h4 id="Redis主从复制的要点"><a href="#Redis主从复制的要点" class="headerlink" title="Redis主从复制的要点"></a>Redis主从复制的要点</h4><ol>
<li>Reids使用异步方式进行复制；</li>
<li>一个主服务器可以有多个从服务器；</li>
<li>一个从服务器也可以接受其他从服务器的连接(可以简单记为薪火相传)；</li>
<li>Redis主从复制不会阻塞主服务器端，也就是若干个从服务器进行初始化同步时，主服务器仍然能够处理请求；</li>
<li>主从复制也不阻塞从服务器端。当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在redis.conf配置文件是这么配置的。否则的话，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是，当初始同步完成后，需要删除旧的数据集和加载新的数据集，在这个短暂的时间内，从服务器会阻塞连接进来的请求；</li>
<li>主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余；</li>
<li>使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。但是这个配置要确保主服务器不会自动重启（要获得更多信息请阅读下一段);<h4 id="当主服务器不进行持久化时复制的安全性"><a href="#当主服务器不进行持久化时复制的安全性" class="headerlink" title="当主服务器不进行持久化时复制的安全性"></a>当主服务器不进行持久化时复制的安全性</h4>在进行主从复制设置时，强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。<br>为什么不持久化的主服务器自动重启非常危险呢？</li>
</ol>
<p>为了更好的理解这个问题，看下面这个失败的例子，其中主服务器和从服务器中数据库都被删除了。</p>
<ol>
<li><p>我们设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</p>
</li>
<li><p>这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</p>
</li>
</ol>
<ol start="3">
<li>节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。<br>当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。<br>如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</li>
</ol>
<p>综上所述：<strong>关闭持久化并允许自动重启的主服务器，在做主从同步时，可能导致所有服务器的数据都被清空</strong></p>
<h4 id="Redis主从复制的原理"><a href="#Redis主从复制的原理" class="headerlink" title="Redis主从复制的原理"></a>Redis主从复制的原理</h4><p>如果你设置了一个从服务器，在连接时它发送了一个SYNC命令，不管它是第一次连接还是再次连接都没有关系。<br>然后主服务器开始后台存储，并且开始缓存新连接进来的修改数据的命令。当后台存储完成后，主服务器把数据文件发送到从服务器，从服务器将其保存在磁盘上，然后加载到内存中。然后主服务器把刚才缓存的命令发送到从服务器。这是作为命令流来完成的，并且和Redis协议本身格式相同。当主从服务器之间的连接由于某些原因断开时，从服务器可以自动进行重连接。当有多个从服务器同时请求同步时，主服务器只进行一个后台存储。<br>当连接断开又重新连上之后，一般都会进行一个完整的重新同步，但是从Redis2.8开始，只重新同步一部分也可以。</p>
<h5 id="部分重新同步"><a href="#部分重新同步" class="headerlink" title="部分重新同步"></a>部分重新同步</h5><p>从Redis 2.8开始，如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步。<br>它的工作原理是这样，主服务器端为复制流维护一个内存缓冲区（in-memory backlog）。主从服务器都维护一个复制偏移量（replication offset）和master run id ，当连接断开时，从服务器会重新连接上主服务器，然后请求继续复制，假如主从服务器的两个master run id相同，并且指定的偏移量在内存缓冲区中还有效，复制就会从上次中断的点开始继续。如果其中一个条件不满足，就会进行完全重新同步（在2.8版本之前就是直接进行完全重新同步）。因为主运行id不保存在磁盘中，如果从服务器重启了的话就只能进行完全同步了。<br>部分重新同步这个新特性内部使用PSYNC命令，旧的实现中使用SYNC命令。Redis2.8版本可以检测出它所连接的服务器是否支持PSYNC命令，不支持的话使用SYNC命令。</p>
<h5 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h5><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： </p>
<ol>
<li>从服务器连接主服务器，发送SYNC命令； </li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； </li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； </li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； <h5 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h5>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。<br>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。<h4 id="只读从服务器"><a href="#只读从服务器" class="headerlink" title="只读从服务器"></a>只读从服务器</h4>从Redis 2.6开始，从服务器支持只读模式，并且是默认模式。这个行为是由Redis.conf文件中的slave-read-only 参数控制的，可以在运行中通过CONFIG SET来启用或者禁用。<br>只读的从服务器会拒绝所有写命令，所以对从服务器不会有误写操作。但这不表示可以把从服务器实例暴露在危险的网络环境下，因为像DEBUG或者CONFIG这样的管理命令还是可以运行的。不过你可以通过使用rename-command命令来为这些命令改名来增加安全性。<br>你可能想知道为什么只读限制还可以被还原，使得从服务器还可以进行写操作。虽然当主从服务器进行重新同步或者从服务器重启后，这些写操作都会失效，还是有一些使用场景会想从服务器中写入临时数据的，但将来这个特性可能会被去掉。</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="http://ifeve.com/redis-replication/" target="_blank" rel="noopener">reids官方文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/Redis学习笔记之Pipeline(管道)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/Redis学习笔记之Pipeline(管道)/" itemprop="url">Redis学习笔记——Pipeline(管道)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-16T09:32:02+08:00">
                2018-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为什么会出现Pipeline"><a href="#为什么会出现Pipeline" class="headerlink" title="为什么会出现Pipeline"></a>为什么会出现Pipeline</h4><p>Redis的pipeline(管道)功能在命令行中没有，但是redis是支持这个功能的，之所以存在这个功能，是因为Redis的server的处理能力很强，但是由于收到的处理请求很少，导致吞吐量很小。这就导致大量的时间花费在客户端和服务器的通信上了。当client 使用pipelining 发送命令时，redis server必须将部分请求放到队列中（使用内存），执行完毕后一次性发送结果；如果发送的命令很多的话，建议对返回的结果加标签，当然这也会增加使用的内存；</p>
<h4 id="Pipeline的原理"><a href="#Pipeline的原理" class="headerlink" title="Pipeline的原理"></a>Pipeline的原理</h4><p>而管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline通过减少客户端与redis的通信次数来实现降低往返延时时间，而且Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。 Pipeline 的默认的同步的个数为53个，也就是说arges中累加到53条数据时会把数据提交。<br>需要注意到是用 pipeline方式打包命令发送，redis必须在处理完所有命令前先缓存起所有命令的处理结果。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。具体多少合适需要根据具体情况测试。</p>
<h4 id="Pipeline的使用场景"><a href="#Pipeline的使用场景" class="headerlink" title="Pipeline的使用场景"></a>Pipeline的使用场景</h4><p>Pipeline在某些场景下非常有用，比如有多个command需要被“及时的”提交，而且他们对相应结果没有互相依赖，对结果响应也无需立即获得，那么pipeline就可以充当这种“批处理”的工具；而且在一定程度上，可以较大的提升性能，性能提升的原因主要是TCP连接中减少了“交互往返”的时间。但是对那些对可靠性要求很高，每次操作都需要立马知道这次操作是否成功是否数据写入了redis,那么pipeline就不适合了。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/varyall/article/details/81205183" target="_blank" rel="noopener">10个常见的Redis面试”刁难”问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/15/Redis学习笔记——Redis中的事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/15/Redis学习笔记——Redis中的事务/" itemprop="url">Redis学习笔记——Redis中的事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-15T17:16:32+08:00">
                2018-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Redis事务简介"><a href="#Redis事务简介" class="headerlink" title="Redis事务简介"></a>Redis事务简介</h4><p>Redis事务可以一次执行多个命令，并且带有以下两个重要的保证：</p>
<ol>
<li>事务是一个单独隔离操作：事务中所有的命令都会序列化，按顺序地执行。事务在执行过程中，不会被其他客户端发送过来的命令所打断；</li>
<li>事务是一个原子性，要么全部执行成功，要么全部都没有被处理；<br>一个事务从开始到执行会经历以下三个阶段：</li>
<li>开始事务；</li>
<li>命令入队；</li>
<li>执行事务；<br>redis中事务与关系数据库中的事务的联系：与关系型数据库中的事务不同，redis中的事务是不支持回滚的(语法错误除外)，redis中的事务机制保证事务中的指令一次执行不会被其他指令插入影响；</li>
</ol>
<h4 id="redis中的事务命令"><a href="#redis中的事务命令" class="headerlink" title="redis中的事务命令"></a>redis中的事务命令</h4><p>Discard：取消事务，放弃执行事务块内的所有指令；<br>Exec:执行所有事务块内的命令；<br>Multi:标记一个事务块的开始；<br>Unwatch:取消watch命令对所有key的监视；<br>Watch key[key…]：监视一个key，如果在事务执行之前这个(或者这些key)被其他命令所改动，那么事务将被打断；</p>
<h4 id="redis事务中的错误"><a href="#redis事务中的错误" class="headerlink" title="redis事务中的错误"></a>redis事务中的错误</h4><p>在redis事务中，可能发生两种错误：</p>
<ol>
<li><p>命令可能排队失败，如命令的语法错误(如参数的数量错误…)，或者一些重要的环境问题，如内存不足，从 Redis 2.6.5 开始, 在命令排队期间发生错误，Redis会拒绝执行EXEC，并返回一个错误，然后自动放弃这个事务。这可以理解为Java中的编译时期的错误告诉开发者必须自己先进行处理。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 89</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k99 99</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k900</span><br><span class="line">(error) ERR wrong number of arguments for &apos;set&apos; command</span><br><span class="line">127.0.0.1:6379&gt; get k99</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. //事务执行失败</span><br><span class="line">127.0.0.1:6379&gt; get k1   //里面的操作都没有被执行</span><br><span class="line">&quot;22&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当exec后发现一些指令可能执行失败了，如在一个字符串上进行了加的操作。此时其他的正确的操作仍然执行成功；这可以理解为java中的运行时错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;22&quot;</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 90</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 string</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; incr k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an integer or out of range</span><br><span class="line">4) &quot;90&quot;</span><br><span class="line">5) &quot;string&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Redis中为何不支持事务回滚"><a href="#Redis中为何不支持事务回滚" class="headerlink" title="Redis中为何不支持事务回滚"></a>Redis中为何不支持事务回滚</h4><p>Redis命令在事务中可能会执行失败，但是redis事务中不会回滚，而是继续会执行余下的命令。这样做的主要原因是：</p>
<ol>
<li>只有当发生语法错误，redis命令才会执行失败，这意味着这些错误都是程序性的错误，这类错误在开发过程中就能够解决，几乎不会出现在生产环境中；</li>
<li>由于不要进行回滚，redis内部更加简单，运行速度更快；</li>
</ol>
<h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>WATCH 命令为事务提供一个check-and-set (CAS) 行为。这个命令使得Exec的执行必须要满足一个条件：如果watch的keys 没有一个被更改(但它们可以在事务中被修改)，则执行事务；不然，就不会执行这个事务。(注意，如果你 WATCH了一个有生命周期的key，并且这个key过期了， EXEC 依然会执行)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/14/Redis学习笔记——Redis持久化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/14/Redis学习笔记——Redis持久化/" itemprop="url">Redis学习笔记——Redis持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-14T18:13:51+08:00">
                2018-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Redis持久化的定义"><a href="#Redis持久化的定义" class="headerlink" title="Redis持久化的定义"></a>Redis持久化的定义</h4><p>Redis的数据操作都在内存中进行，如果发生服务器宕机，内存中的数据就会丢失。持久化就是将数据保存在磁盘上，redis中常用的持久化方法为：RDB和AOF;</p>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><p>RDB方式就是将redis中的数据生成一个完整的快照，然后以二进制文件的形式保存在磁盘上，当需要进行恢复时，在从磁盘加载到内存中。</p>
<h5 id="三种触发方式"><a href="#三种触发方式" class="headerlink" title="三种触发方式"></a>三种触发方式</h5><p>1.save命令触发：这种触发方式是一种同步触发方式，该方式会造成Redis的阻塞。所有的数据操作命令都要排队等他完成。<br>文件策略：他会生成一个临时文件，save执行完后就会替换老的文件；<br>2.bgsave命令触发方式：这种方式是一种异步方式，客户端对服务器下达bgsave命令时，redis会fork出一个子进程进行RDB文件的生成，当RDB生成完毕后子进程会反馈给主进程。fork子进程时也会阻塞，不过正常情况下fork的过程非常快。<br>文件策略：和save的相同；<br>save触发方式和bgsave触发方式的比较：<br>1.save触发方式是同步的，会阻塞客户端的操作，而bgsave触发方式是异步的基本上不会阻塞客户端的操作(除了fork子进程的时候会阻塞，但是这个过程很快)；<br>2.save触发方式实在主进程中进行RDB文件的生成，而bgsave是在子进程中进行RDB文件的生成；<br>3.save方式不会消耗内存，但是bgsave fork一个子进程中会消耗内存；<br>3.规则自动触发方式<br>当满足一定的规则时，会自动生成文件，这些规则需要在配置文件中进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">900 1    900秒内改变1条数据会自动生成RDB文件</span><br><span class="line">300 10   300秒内改变10条数据，会自动生成RDB文件</span><br><span class="line">60  10000  60秒内改变1万条数据，会自动生成RDB文件</span><br></pre></td></tr></table></figure></p>
<p>4.其它的一些触发方式<br>1.全量复制：主从复制时，master会自动生成RDB文件；<br>2.debug reload:提供debug级别的重启，不清空内存的一种重启方式，但是会自动生成RDB文件；<br>3.shutdown:当执行shutdown指令时，会自动生成RDB文件；</p>
<h5 id="RDB持久化的优缺点"><a href="#RDB持久化的优缺点" class="headerlink" title="RDB持久化的优缺点"></a>RDB持久化的优缺点</h5><p>RDB方式进行持久化时，速度快，生成的文件比较小，但是在生成快照时候，会造成最后一个分片时间内操作的数据的丢失；</p>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>AOF持久化就是将所有的写操作都写到日志文件中，当服务器发生宕机时，只需要重新从头到尾执行一下这个文件就可以了；<br>AOF的三种策略：<br>always:每一步写操作立即同步到日志文件中；优点是即使宕机也不会存在数据的丢失，缺点是频繁的进行IO操作， 对系统的性能影响较大；<br>everysec:每秒中同步一次；缺点是会丢失最后一秒钟的数据<br>no:刷新策略交给操作系统；</p>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>使用AOF持久化的时候，有一个重要的问题就是随着操作的增多，日志文件会越来越大，那么有什么方法解决这个问题呢？redis采用重写的方式有效的解决了这个问题。AOF重写就是把过期的、没用的、重复的以及可优化的命令，进行化简。只取最终有价值的结果。虽然写入操作很频繁，但系统定义的key的量是相对有限的。AOF重写并不是针对原来的日志文件，而是对内存中的数据进行一次回溯，回溯成aof文件。</p>
<h5 id="AOF重写的触发方式"><a href="#AOF重写的触发方式" class="headerlink" title="AOF重写的触发方式"></a>AOF重写的触发方式</h5><p>1.bgrewriteaof命令触发AOF重写：redis客户端向Redis发bgrewriteaof命令，redis服务端fork一个子进程去完成AOF重写。<br>2.AOF自动重写的触发时机，同时满足以下两点）：<br>aof_current_size &gt; auto-aof-rewrite-min-size<br>aof_current_size - aof_base_size/aof_base_size &gt; auto-aof-rewrite-percentage</p>
<h4 id="两种持久化方式的比较"><a href="#两种持久化方式的比较" class="headerlink" title="两种持久化方式的比较"></a>两种持久化方式的比较</h4><p>1.RDB持久化方式数据恢复的速度快，但是会丢失生成最后一次快照后的数据，适合规模较大的数据但是对数据的完整性不是很敏感；AOF持久化可以保证数据的完整性，但是恢复的速度比较慢；<br>2.RDB文件的体积小，AOF日志文件的体积大；</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>RDB持久化方式和AOF持久化方式可以同时存在，当两者同时存在时，进行数据恢复时会选择AOF进行数据恢复，因为它保存的数据更加完整。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/12/Redis学习笔记——五大常用的数据类型之ZSet(SortedSet)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/Redis学习笔记——五大常用的数据类型之ZSet(SortedSet)/" itemprop="url">Redis学习笔记——五大常用的数据类型之ZSet(SortedSet)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T14:45:27+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>zset中的数据就是在set的基础上，加一个score值，之前set是k1 v1 v2 v3 现在是k1 score1 v1 socer2 v2;<br>1.zadd/zrange<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zadd zset1 60 v1 70 v2 80 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1 withscores //输出的元素带score</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;60&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;80&quot;</span><br><span class="line">5) &quot;v4&quot;</span><br><span class="line">6) &quot;90&quot;</span><br><span class="line">7) &quot;v5&quot;</span><br><span class="line">8) &quot;100&quot;</span><br></pre></td></tr></table></figure></p>
<p>2.zrangebyscore key 开始score结束score:查询在某一个范围之间的元素<br>“(“:表示不包含，limit:作用是限制返回元素的个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br><span class="line">5) &quot;v5&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrangebyscore zset1 70 90 //70-90之间的元素，包含70也包含90</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v4&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrangebyscore zset1 70 (90</span><br><span class="line">1) &quot;v2&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrangebyscore zset1 (70 (90  //70-90之间的元素，不包含70也不包含90</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrangebyscore zset1 60 90</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrangebyscore zset1 60 90 limit 2 2 //从第二个元素开始取两个</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v4&quot;</span><br></pre></td></tr></table></figure></p>
<p>3.zrem key 某score下对应的value值，作用是删除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br><span class="line">5) &quot;v5&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrem zset1 v2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br><span class="line">3) &quot;v4&quot;</span><br><span class="line">4) &quot;v5&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.zcard/zcount key score区间/zrank key values值，作用是获得下标值/zsocre key 对应的值，获得分数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zrange zset1 0 -1 withscores</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;60&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;80&quot;</span><br><span class="line">5) &quot;v4&quot;</span><br><span class="line">6) &quot;90&quot;</span><br><span class="line">7) &quot;v5&quot;</span><br><span class="line">8) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zcard zset1 //分数和后面的值是一体的，所以为4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[6]&gt; zcount zset1 60 80 //统计分数在60到80分之间的数量</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[6]&gt; zrank zset1 v4  //获得v4的排名从0开始</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[6]&gt; zscore zset1 v4 //获得v4的score</span><br><span class="line">&quot;90&quot;</span><br></pre></td></tr></table></figure></p>
<p>5.zrevrank key values值，作用是逆序获得下标值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zrevrank zset1 v4 //倒过来的顺序，也是从0开始计数</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>6.zrevrange/zrevrangebyscore key score1 score2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; zrevrange zset1 0 -1 //逆序遍历元素</span><br><span class="line">1) &quot;v5&quot;</span><br><span class="line">2) &quot;v4&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v1&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; zrevrangebyscore zset1 90 70 //注意范围也要倒着写</span><br><span class="line">1) &quot;v4&quot;</span><br><span class="line">2) &quot;v3&quot;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/Redis学习笔记——五大常用的数据类型之Hash/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/Redis学习笔记——五大常用的数据类型之Hash/" itemprop="url">Redis学习笔记——五大常用的数据类型之Hash</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-10T16:22:21+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Redis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Hash数据类型仍然是KV模式，但是v是一个键值对<br>1.hset/hget/hmset/hmget/hgetall/hdel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; hset hash2 id 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[6]&gt; hset hash2 age 77</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[6]&gt; hset hash2 name liu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[6]&gt; hget hash2 id</span><br><span class="line">&quot;5&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hmset hash2 food xiangjiao drink coffer</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[6]&gt; hmget hash2 id name age</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;liu&quot;</span><br><span class="line">3) &quot;77&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hgetall hash2</span><br><span class="line"> 1) &quot;id&quot;</span><br><span class="line"> 2) &quot;5&quot;</span><br><span class="line"> 3) &quot;age&quot;</span><br><span class="line"> 4) &quot;77&quot;</span><br><span class="line"> 5) &quot;name&quot;</span><br><span class="line"> 6) &quot;liu&quot;</span><br><span class="line"> 7) &quot;food&quot;</span><br><span class="line"> 8) &quot;xiangjiao&quot;</span><br><span class="line"> 9) &quot;drink&quot;</span><br><span class="line">10) &quot;coffer&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hdel hash2 id</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[6]&gt; hgetall hash2</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;77&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">4) &quot;liu&quot;</span><br><span class="line">5) &quot;food&quot;</span><br><span class="line">6) &quot;xiangjiao&quot;</span><br><span class="line">7) &quot;drink&quot;</span><br><span class="line">8) &quot;coffer&quot;</span><br></pre></td></tr></table></figure></p>
<p>2.hlen:判断hash中元素的个数；hexists key 在key里面某个值的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; hlen hash2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[6]&gt; hexists hash2 id</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[6]&gt; hexists hash2 age</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>
<p>3.hkeys/hvals<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; hkeys hash2</span><br><span class="line">1) &quot;age&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">3) &quot;food&quot;</span><br><span class="line">4) &quot;drink&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hvals hash2</span><br><span class="line">1) &quot;77&quot;</span><br><span class="line">2) &quot;liu&quot;</span><br><span class="line">3) &quot;xiangjiao&quot;</span><br><span class="line">4) &quot;coffer&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.hincrby/hincrbyfloat //加上一个整数或者小数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; hget hash2 age</span><br><span class="line">&quot;77&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hincrby hash2 age 3</span><br><span class="line">(integer) 80</span><br><span class="line">127.0.0.1:6379[6]&gt; hincrbyfloat hash2 age 0.5</span><br><span class="line">&quot;80.5&quot;</span><br></pre></td></tr></table></figure></p>
<p>5.hsetnx //不存在则添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[6]&gt; hgetall hash2</span><br><span class="line"> 1) &quot;age&quot;</span><br><span class="line"> 2) &quot;80.5&quot;</span><br><span class="line"> 3) &quot;name&quot;</span><br><span class="line"> 4) &quot;liu&quot;</span><br><span class="line"> 5) &quot;food&quot;</span><br><span class="line"> 6) &quot;xiangjiao&quot;</span><br><span class="line"> 7) &quot;drink&quot;</span><br><span class="line"> 8) &quot;coffer&quot;</span><br><span class="line"> 9) &quot;id&quot;</span><br><span class="line">10) &quot;8&quot;</span><br><span class="line">127.0.0.1:6379[6]&gt; hsetnx hash2 id 2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[6]&gt; hsetnx hash2 num 2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/liuwuwu.jpg" alt="LiuWuWu">
            
              <p class="site-author-name" itemprop="name">LiuWuWu</p>
              <p class="site-description motion-element" itemprop="description">Tomorrow will be better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuWuWu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
