<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Tomorrow will be better">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder Paradise">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Coder Paradise">
<meta property="og:description" content="Tomorrow will be better">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder Paradise">
<meta name="twitter:description" content="Tomorrow will be better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>Coder Paradise</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder Paradise</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I am coding, I am happy.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/truncate、delete（不带where子句）与drop的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/truncate、delete（不带where子句）与drop的区别/" itemprop="url">truncate、delete（不带where子句）与drop的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T10:23:04+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>郑重声明：</strong>本文转载至<a href="https://blog.csdn.net/htl258/article/details/4129228" target="_blank" rel="noopener">truncate、delete（不带where子句）与drop的区别 </a></p>
<h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>truncate、delete（不带where子句）与drop的异同点：<br>相同之处：    三者均会删除表内的data。</p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><1>、truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）        drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger), 索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。  </1></p>
<p><2>、delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。      truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚；操作不触发 trigger。  </2></p>
<p><3>、delete语句不影响表所占用的 extent（段）,高水线（high watermark)保持原位置不动。        drop语句将表所占用的空间全释放掉。truncate语句缺省情况下将空间释放到 minextents 个 extent,除非使用 renuse storage;truncate 会将高水线(high watermark)复位（回到最初位置）。  </3></p>
<p><4>、速度： 一般而言，drop &gt; truncate &gt; delete。  </4></p>
<p><5>、安全性：在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。如果是整理表内部的碎片，可以用truncate并结合reuse storage,再重新导入/插入数据。Truncate是SQL中的一个删除数据表内容的语句，用法是：<br>TRUNCATE TABLE [Table Name]。 </5></p>
<h4 id="truncate的用法和原理"><a href="#truncate的用法和原理" class="headerlink" title="truncate的用法和原理"></a>truncate的用法和原理</h4><p>下面是对Truncate语句在用法和原理的说明：<br>Truncate table 表名 速度快,而且效率高,因为:<br>truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。<br>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。<br>TRUNCATE TABLE 不能用于参与了索引视图的表。</p>
<p>还有另外一篇写的比较好的文章<br><a href="https://www.cnblogs.com/andy-zhou/p/5316023.html" target="_blank" rel="noopener"> 数据库面试常问的一些基本概念</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/Mysql事务和事务引发的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/Mysql事务和事务引发的问题/" itemprop="url">Mysql事务和事务引发的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T17:19:27+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h4><p>在mysql中事务满足ACID特性：<br><strong>原子性(A)</strong>：事务中定义的一组操作要么全部成功，要么全部失败；<br><strong>一致性(C)</strong>: 事务执行前后，数据的完整性保持不变，比如银行的转账业务，A给B转账100，转账前后A和B的余额的总数是保持不变的；<br><strong>隔离性(I)</strong>: 当多个事务同时操作一个数据库时，他们之间互不干扰；<br><strong>持久性(I)</strong>:事务一旦提交，他对数据库的改变是永久性的，不能够回滚；</p>
<h4 id="事务引发的问题"><a href="#事务引发的问题" class="headerlink" title="事务引发的问题"></a>事务引发的问题</h4><p>脏读: 一个事物读取到另外一个事物未提交的数据；<br>不可重复读: 同一个事务中前后两次读取到的数据不一样，主要是读取到了另外一个事务已经提交的数据造成的；<br>幻读：同一个事务中前后两次读取到的数据不一样，主要指的对结果集进行查询，幻读主要针对的是另外一个事务向数据库中插入了新的数据，而不可重复读针对的是另外一个事务修改了数据库中的数据；<br>更新丢失：两个事务对数据库中的同一数据进行修改，后面修改的内容会覆盖前面修改的内容，导致前一次修改的数据与丢失；</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>读未提交(read uncommitted)：是限制性最低的隔离级别，可以有效的解决更新丢失的问题，如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现；<br>读已提交(read committed): 会引发不可重复读取和虚读，但避免脏读。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现。<br>可重复读取（Repeatable Read）(mysql默认级别)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据和虚读。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。<br>序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。</p>
<h4 id="隔离级别和锁的关系"><a href="#隔离级别和锁的关系" class="headerlink" title="隔离级别和锁的关系"></a>隔离级别和锁的关系</h4><ol>
<li>在Read Uncommitted级别下，读操作不加S锁；</li>
<li>在Read Committed级别下，读操作需要加S锁，但是在语句执行完以后释放S锁；</li>
<li>在Repeatable Read级别下，读操作需要加S锁，但是在事务提交之前并不释放S锁，也就是必须等待事务执行完毕以后才释放S锁。</li>
<li>在Serialize级别下，会在RepeatableRead级别的基础上，添加一个范围锁。保证一个事务内的两次查询结果完全一样，而不会出现第一次查询结果是第二次查询结果的子集。</li>
</ol>
<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="https://blog.csdn.net/baidu_37107022/article/details/77481670" target="_blank" rel="noopener">数据库隔离级别—MySQL的默认隔离级别就是Repeatable,Oracle默认Read committed，最高级别Serializable</a></p>
<p><a href="https://blog.csdn.net/tr1912/article/details/81988459" target="_blank" rel="noopener">Mysql中的事务详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/数据库中的约束/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/数据库中的约束/" itemprop="url">数据库中的约束</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T13:43:14+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在网上看了几篇大佬写的关于约束的文章，觉得挺不错的，自己整理了一下。原文见参考文献。<br>约束的作用：用来对数据业务规则和数据完整性进行实施、维护。</p>
<h4 id="约束的类型"><a href="#约束的类型" class="headerlink" title="约束的类型"></a>约束的类型</h4><p>数据库中常见的约束有5种，分别为：检查约束、唯一约束、默认约束、外键约束、主键约束。<br>主键约束（Primary Key constraint）：要求主键列数据唯一，并且不允许为空。<br>唯一约束（Unique constraint）：要求该列唯一，允许为空，但只能出现一个空值。<br>检查约束（Check constraint）：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。<br>默认约束（Default constraint）：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。<br>外键约束（Foreign Key constraint）：用于在两个表之间建立关系，需要指定引用主表的哪一列。</p>
<h4 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h4><h5 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------为用户名添加主键约束---------------</span></span><br><span class="line">alter table UserId</span><br><span class="line"><span class="function">add constraint PK_UserId primary <span class="title">key</span> <span class="params">(UserId)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------对学号添加唯一约束---------------</span></span><br><span class="line">alter table Student</span><br><span class="line"><span class="function">add constraint S_id <span class="title">unique</span>  <span class="params">(student_id)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="添加默认约束"><a href="#添加默认约束" class="headerlink" title="添加默认约束"></a>添加默认约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table UserInfo</span><br><span class="line"><span class="function">add constraint DF_UserAddress <span class="title">default</span> <span class="params">(‘地址不详’)</span> <span class="keyword">for</span> UserAddress</span></span><br></pre></td></tr></table></figure>
<h5 id="添加检查约束"><a href="#添加检查约束" class="headerlink" title="添加检查约束"></a>添加检查约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//-----------检查取值是否在合理范围内---------------</span></span><br><span class="line">alter table UserInfo</span><br><span class="line"><span class="function">add constraint CK_UserAge <span class="title">check</span> <span class="params">(UserAge between <span class="number">20</span> and <span class="number">40</span>)</span></span></span><br><span class="line"><span class="function">　　<span class="comment">//-----------检查性别取值是否正确---------------</span></span></span><br><span class="line"><span class="function">alter table UserInfo</span></span><br><span class="line"><span class="function">add constraint CK_UserSex <span class="title">check</span> <span class="params">(UserSex=’男’ or UserSex=’女′)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------主表UserInfo和从表UserOrder建立关系，关联字段UserId---------------</span></span><br><span class="line">　alter table UserOrder</span><br><span class="line">　<span class="function">add constraint FK_UserId_UserId foreign <span class="title">key</span><span class="params">(UserId)</span>references <span class="title">UserInfo</span><span class="params">(UserId)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h4><p>一般，我们看到术语“索引”和“键”交换使用，但实际上这两个是不同的。索引是存储在数据库中的一个物理结构，键纯粹是一个逻辑概念。键代表创建来实施业务规则的完整性约束。索引和键的混淆通常是由于数据库使用索引来实施完整性约束。<br>(1)     <strong>主键索引和主键有什么关系？</strong><br>主键索引是创建主键的时候系统自动创建的索引，主键要求不重复，不为空，但是他如何判断有效率呢？当然是建索引了，老是全表遍历还不疯掉。<br>所以建立主键会自动的建立主键索引。<br>(2)    <strong> 主键和唯一键的区别在于唯一键可以为空，主键不可以</strong><br>(3)    <strong> 建立唯一约束和唯一索引又什么区别？</strong><br>同理，建立唯一约束的时候，也会自动的创建唯一索引。建立唯一索引可以说是唯一约束的一种手段。<br>基本上，实现起来是没有什么区别的。如果实在理解不了，就当一样好了。<br>(5)     <strong>约束和主键有什么区别？</strong><br>约束一般有主键约束，外键约束，唯一约束等。<br>分别为primary key，foreign key，unique 其中主键约束只是约束的一种。<br>其实他们是不同概念的东西。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.cnblogs.com/willingtolove/p/9215330.html" target="_blank" rel="noopener">SQL数据库中的五种约束</a><br><a href="https://blog.csdn.net/fly910905/article/details/78056871" target="_blank" rel="noopener">唯一约束和唯一索引区别</a><br><a href="https://blog.csdn.net/dlodj/article/details/7017331" target="_blank" rel="noopener">键、索引、约束及其区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/equals与==的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/equals与==的区别/" itemprop="url">equals与==的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T08:56:20+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天有一个同学问我java中equals和==的区别，感觉自己知道的也不是很全面，很感激他，让我知道了自己知识面的缺陷。所以打算趁这个机会把他们弄清楚。<br>java中“==”和equals的含义<br>java中的数据类型可以分为两类：（1）基本数据类型：byte、char、short、int、float、double、long、boolean。他们之间的比较用“==”，比较的是他们的值。（2）引用数据类型，当他们用“==”时比较的是他们在内存中的存放地址，所以除非是同一个new出来的对象，他们的比较后的结果为true,反之结果为false。Java中equals方法默认的初始行为是比较对象的地址，即初始状态下equals与“==”是等效的，这是因为Java中所有的类都是继承Object，这个类中定义的equals方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是一般的对象都会根据自己的情况重写这个equals方法，重写后的equals方法一般被用来比较对象的值是否相同。<br>总结<br>“==”的功能：对于基本数据类型按值比较，对于引用数据类型比较地址是否相同。<br>equals的功能：在默认情况下（未重写前）它与“==”可以说是等效的，都是比较地址是否相同，但是一般都会重写将他的功能变为比较对象的内容是否相等。<br>String类中的equals方法<br>String类重写了equals方法，使得它的功能变为比较两个对象的内容是否相等，它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">              String anotherString = (String)anObject;</span><br><span class="line">              <span class="keyword">int</span> n = value.length;</span><br><span class="line">              <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                 <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                 <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                 <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                     i++;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看一个特殊的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">"Monday"</span>;</span><br><span class="line">       String s2 = <span class="keyword">new</span> String(<span class="string">"Monday"</span>);</span><br><span class="line">         <span class="keyword">if</span> (s1 == s2)</span><br><span class="line">       &#123;System.out.println(<span class="string">"s1 == s2"</span>);&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         System.out.println(<span class="string">"s1 != s2"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">if</span> (s1.equals(s2)) &#123;</span><br><span class="line">         System.out.println(<span class="string">"s1 equals s2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"s1 not equals s2"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的结果出乎我们的意料，“==”方法的结果为false，这是为什么呢？原来程序在运行时会创建一个字符串缓冲池，如果使用s2=”Monday”创建字符串时程序会在字符串缓冲池中寻找值相同的对象，但是一旦使用了new关键字，不管缓冲池中是否存在值相同的对象，它都会新建一个（可以理解为我不要旧的，我要新的）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/接口/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/接口/" itemprop="url">接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T13:15:11+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h4><p>对于有些问题我们不仅要知其然，还要知其所以然。不知道大家有没有思考过为什么java的设计者会开发出接口？《Thinking in java》中是这样介绍的：接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法，可以这样理解接口就是将功能和实现分离，让我们可以根据自己的需要来实现这个功能。还有一点就是接口可以用来完全解耦，比如有一个方法他的参数是一个类A，那么他只能接受A或者A的子类，如果该方法接受的参数是一个接口，那么任何实现了该接口的对象都可以作为该方法的参数。<br>接口和抽象类的区别<br>抽象类是接口和类的中间状态，他们之间的主要区别如下：<br>抽象类中的方法可以有具体的实现，而接口不行；<br>抽象类可以有main方法，可以运行，而接口中不能有main方法，不能运行；<br>抽象类中的访问控制权限可以非public而接口中的访问控制权限必需是public的；<br>抽象类是一个类，继承时用关键字extends,而接口是用关键字implents;<br>虽然他们都不能新建对象，但是抽象类中是可以有构造器的，而接口中不能有构造器；<br>接口中的域为什么是static和final？<br>我们首先解释为何接口中的域是static的，因为一个类是可以实现多个接口的，如果每个接口中都有一个相同的变量但是值不同那么，这个类该继承哪个呢？所以将变量声明为static的就可以很好的解决这个问题，我们可以通过接口名来区分变量的值。至于为什么要为final这是因为接口的域表达的是很多类的共有属性，当然不希望被某一个类私自串改。有一点需要记住的是接口中的域和方法都是public修饰的。还有需要注意的是接口的修饰符只能是public或默认的。</p>
<h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h4><p>一个接口可以继承多个接口，用关键字extends，千万不要觉得与接口有关的都用关键字implements。这在一定程度上可以认为实现了多重继承。关于组合接口时的名字冲突问题我觉得《Thinking in java》中有一个例子举得比较好P181，在这引用一下：<br><code>`</code>java<br>interface I1{<br>void f();<br>}    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/重载/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/重载/" itemprop="url">重载</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-24T19:11:01+08:00">
                2018-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近突然觉得有必要重新整理一下Java基础知识，毕竟温故而新，打算按照“Thinking in java”中的章节安排重新梳理一下。首先介绍方法的重载,方法重载指的是方法名相同，具体的实现和参数列表等可以不同。就好像洗衣服包括：洗牛仔衣、洗球衣一样。<br>　　我们可以通过方法的参数列表中参数的类型和数目对重载的方法进行区分，以便保证方法调用的正确性，可能有人会问，为什么不可以通过方法的返回值类型进行区分呢？这是因为我们在调用方法时并不总是为了得到它的返回值，有时仅仅为了得到调用它时产生的“副作用”。如下面的列子所示当在main()函数中调用a()方法时,无法区分重载的方法中该调用哪个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">　　<span class="keyword">new</span> A().a();</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　还有在参数为基本类型时要注意数据类型的提升，也就是当传入的类型小于形式参数的类型，实际数据的类型就会提升，如int形参提升为long和double。有一点需要注意char提升为int。具体的例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(<span class="keyword">double</span> a)</span></span>&#123;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info2</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> B().info(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">new</span> B().info(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当也就是当传入的类型大于形式参数的类型时必须进行类型窄化转换，否则会报错。<br>　　最后总结一下关键字this的用法：(1)当在一个构造函数中需要调用其他的构造函数时，为了实现代码的重复利用可以用this+参数列表的形式直接调用现成的构造器，但是this必须放在第一句；(2)当类的成员变量和方法的形参同名时，为了避免成员变量被覆盖通常在变量前加this；(3)this可以指代引用当前函数所属类的对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/20/简单排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/20/简单排序/" itemprop="url">简单排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-20T11:56:09+08:00">
                2018-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简单排序简介"><a href="#简单排序简介" class="headerlink" title="简单排序简介"></a>简单排序简介</h3><p>排序指的是将某些杂乱无章的对象，按照某一逻辑顺序重新排列的过程，在java中一般通过接口来对实现对象的比较，常用的接口是Comparable接口和Comparator接口，这两个接口存在如下几点差异：<br>(1)Comparable接口需要实现compareTo()方法，而Comparator接口需要实现compare()方法即两者实现的方法不同；<br>(2)Comparable接口中的中的compareTo()方法在类的内部，参数只有一个(根据英文意思很好理解)，而Comparator接口的comparator()方法在类的外部,参数有两个，所以Comparable接口使用方便（可以直接调用)但是修改比较麻烦(要到类的里面修改源码),而Comparator使用起来比较麻烦(比较器作为参数传递给比较对象)，但是它比较灵活，我们可以根据不同的应用场景调用不同的比较器而不需要修改类的代码。接下来将介绍几种常用的排序算法。<br>简单排序<br>       简单排序算法包括：插入排序、选择排序、冒泡排序,这些排序算法的思路比较简单，但是复杂度都是O(n^2); </p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的思路是通过遍历的方式将后面待排序的元素与前面有序数组中的元素进行比较，找到插入点，插入点后的元素分别向后移动一位，最后将元素插入到插入点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;<span class="comment">//插入排序的思想是通过将后面的值插入到前面的有序数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i,tem=a[j];</span><br><span class="line">            <span class="comment">//找到应该插入的位置</span></span><br><span class="line">            <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将插入点后的元素后移</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> m=j;m&gt;i;m--)&#123;</span><br><span class="line">                a[m]=a[m-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">                a[i]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">16</span>;</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">new</span> InsertSort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序算法的思路就是不断的比较相邻的两个元素之间的大小，如果左边的元素大于右边，则交换两个元素的位置，反之则不变。这样就可以确保数组最右边的元素是最大的，遍历一次就确定了一个元素的位置便历N次数组就变得有序了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序的思想是通过比较相邻的两个元素使得最大的元素位于最右边</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tem=a[i+<span class="number">1</span>];</span><br><span class="line">                    a[i+<span class="number">1</span>]=a[i];</span><br><span class="line">                    a[i]=tem;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">12</span>;</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">new</span> BubbleSort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的思想是遍历整个数组，用指针min标记最小值的位置，遍历结束后再交换min指向的元素和待排序数组的首元素，也就是不断的选出待排序数组的最小值。<br>//选择排序的思想是不断的选择数组中的最小值，先记住最小值的位置最后在进行交换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min,j;<span class="comment">//用来记录最小值的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            min=i;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(a[min]&gt;a[j])&#123;</span><br><span class="line">                   min=j;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tem=a[i];</span><br><span class="line">            a[i]=a[min];</span><br><span class="line">            a[min]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            a[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">16</span>;</span><br><span class="line">        a[<span class="number">1</span>]=<span class="number">11</span>;</span><br><span class="line">        <span class="keyword">new</span> SelectSort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/17/堆排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/堆排序/" itemprop="url">堆排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T10:17:30+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序:堆排序会用到一个叫做二叉堆的数据结构(父节点的元素大于它左右子节点)，根节点中的元素是最大的。排序的过程分为两个步骤：二叉堆的建立和从上到下的堆排序。建立二叉堆的思路就是将索引为[n/2]到1的元素分别与它的左右节点比较，并交换元素的位置确保根节点中的值最大。从上到下的排序过程思路是：交换最大元素和待排数组最后那个值的位置，从根节点开始比较他与两个子节点的大小，小于则交换。最后将待排序数组大小减一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//堆排序分为两步，第一步是堆的建立，第二步是通过下沉的方法进行排序</span></span><br><span class="line">    <span class="comment">//进行排序时候一般是从N/2开始不断的遍历将节点与两个子节点进行比较，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ech</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=tem;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//-----------------------堆的建立------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> N,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//N的值代表数组的最大索引，k的值代表元素在堆中的位置</span></span><br><span class="line">        <span class="keyword">while</span>(k*<span class="number">2</span>&lt;N)&#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="comment">//找到a[2k]和a[2k+1]中的较大的那个值</span></span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">2</span>*k]&gt;=a[<span class="number">2</span>*k+<span class="number">1</span>])&#123;</span><br><span class="line">               j=<span class="number">2</span>*k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j=<span class="number">2</span>*k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[k])&#123;</span><br><span class="line">                ech(a,j,k);</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//--------------------------上浮函数-----------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> N,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[k/<span class="number">2</span>]&lt;a[k])&#123;</span><br><span class="line">                ech(a,k/<span class="number">2</span>,k);</span><br><span class="line">                k=k/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------下降函数-------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N=a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           sink(a,N,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(N&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            ech(a,<span class="number">1</span>,N--);</span><br><span class="line">            sink(a,N,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            a[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        a[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">new</span> StackSort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/快速排序和归并排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/快速排序和归并排序/" itemprop="url">快速排序和归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T23:37:48+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>归并排序<br>       归并排序:因为简单排序算法的复杂度太大为O(n^2)所以人们设计了一种更加快的算法它在最坏的情况下的比较次数为O(NlogN)。算法的实现需要借助辅助数组，首先将待排数组复制到辅助数组中再将归并后的结果复制回原数组。我们首先介绍一下原地归并的代码。<br>//归并排序的算法复杂度为NlgN（它的比较次数为NlgN,访问数组的次数为6NlgN次）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//原地归并排序，它需要一个辅助数组，将待排序数组复制到辅助数组，归并后再将结果复制到原数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []aa, <span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对a[lo]-a[mid]和a[mid+1]-a[hi]进行归并排序</span></span><br><span class="line">        <span class="keyword">int</span> N=aa.length;</span><br><span class="line">        <span class="keyword">int</span> i=lo;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        bb=<span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="comment">//将数组中的值复制到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;aa.length;k++)&#123;</span><br><span class="line">            bb[k]=aa[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;aa.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                aa[k]=bb[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi)&#123;</span><br><span class="line">                aa[k]=bb[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bb[i]&lt;bb[j])&#123;</span><br><span class="line">               aa[k]=bb[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                aa[k]=bb[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]aa=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            aa[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            aa[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> MergeSort().merger(aa,<span class="number">0</span>,<span class="number">9</span>,<span class="number">19</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;aa.length;i++)&#123;</span><br><span class="line">            System.out.println(aa[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>归并排序分为两大类:自上而下的归并排序和自下而上的归并排序。自上而下的归并排序是通过递归的方法不断的将数组均分为两部分进行并归。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下的归并排序算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergerDUsort</span> <span class="keyword">extends</span> <span class="title">MergeSort</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[]aux;<span class="comment">//定义辅助数组，不然的话在递归调用时会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">     aux=<span class="keyword">new</span> <span class="keyword">int</span> [a.length];</span><br><span class="line">     sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">            sort(a,lo,mid);</span><br><span class="line">            sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">            merger(a,lo,mid,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span> []aa, <span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//对a[lo]-a[mid]和a[mid+1]-a[hi]进行归并排序</span></span><br><span class="line">        <span class="keyword">int</span> i=lo;</span><br><span class="line">        <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将数组中的值复制到辅助数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;aa.length;k++)&#123;</span><br><span class="line">            aux[k]=aa[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;aa.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)&#123;</span><br><span class="line">                aa[k]=aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi)&#123;</span><br><span class="line">                aa[k]=aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;aux[j])&#123;</span><br><span class="line">                aa[k]=aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                aa[k]=aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            a[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> MergerDUsort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从下到上的归并排序：归并的规模先是1(即先将相邻的两个元素进行归并）再不断的倍增知道大于等于数组的规模的一半。它的实现不需要借助递归，通过简单的循环就可以实现。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从下到上的归并排序算法，主要思想就是归并的规模从一开始逐渐变大知道为N-1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergerUDsort</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span>[]aux;<span class="comment">//定义一个辅助数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merger</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=lo,j=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo;k&lt;a.length;k++ )&#123;</span><br><span class="line">            aux[k]=a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;mid)</span><br><span class="line">                a[k]=aux[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;hi)&#123;</span><br><span class="line">                a[k]=aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;aux[j])&#123;</span><br><span class="line">                a[k]=aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[k]=aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]a)</span></span>&#123;</span><br><span class="line">        aux=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">for</span>(size=<span class="number">1</span>;size&lt;a.length;size=size*<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo=<span class="number">0</span>;lo&lt;a.length-size;lo=lo+size*<span class="number">2</span>)&#123;</span><br><span class="line">                merger(a,lo,lo+size-<span class="number">1</span>,Math.min(lo+size+size-<span class="number">1</span>,a.length-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            a[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> MergerUDsort().sort(a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速排序<br>       快速排序:可能有人会觉得归并排序已经足够优秀了，没有必要研究其他排序算法了，这种想法显然是错误的因为归并排序虽然比较次数少，但是它的空间复杂度是不可忽视的。除此之外算法的比较次数并不是评价算法性能好坏的唯一指标(比如访问数组的次数等因素也要考虑)。所以研究一种在时间和空间上平衡的算法是很有必要的。与归并排序总是将数组均等分割归并不同，快速排序的切割点并不是固定的。每次排序总能够确定一个元素的位置，他的左边的元素小于等于他，右边的元素大于等于他。具体实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//快速排序和归并排序一样都是基于分治的思想进行排序来降低算法的复杂度，但是归并排序是平均分割，</span></span><br><span class="line"><span class="comment">// 而快速排序的分割点并不一定是中点，快速排序需要先确定切割点的位置</span></span><br><span class="line">    <span class="comment">//也正是这个原因快速排序是先对数组进行处理再进行递归，而归并排序是先进行递归对数组进行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//切割函数,返回切割点的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saparation</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v = a[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//i从lo+1开始不断的查找，直到找到比v大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (a[++i]&lt; v) <span class="keyword">if</span> (i==hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//j从hi开始不断的遍历数组，直到找到比v小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (v&lt;a[--j]) <span class="keyword">if</span> (j ==lo)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//exc(a, i, j);//有逻辑错误，这句话不能在这如果i的值比j大则不能够交换</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exc(a, i, j);</span><br><span class="line">           <span class="comment">// exc(a,lo,j);//最后的这个交换应该是找到j的位置后再进行交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        exc(a,lo,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exc</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem=a[b];</span><br><span class="line">            a[b]=a[c];</span><br><span class="line">            a[c]=tem;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> min,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo=min;</span><br><span class="line">        <span class="keyword">int</span> hi=max;</span><br><span class="line">        <span class="keyword">if</span>(hi&lt;=lo) <span class="keyword">return</span>;<span class="comment">//只有lo&lt;hi迭代才会继续</span></span><br><span class="line">        <span class="keyword">int</span> j=saparation(a,lo,hi);</span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            a[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> QuickSort().sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速排序算法中还有一种三向切分的开速排序算法，他主要针对的情况是当数组中重复元素比较多的情况，对于有大量重复元素的数组，他能将排序时间从线性对数级别降低到线性级别。它定义三个指针：lt、gt、i。lo到lt-1范围内都是小于那个元素的，lt到i-1都是等于那个比较元素的，i到gt元素不确定，gt+1到hi都是大于那个元素的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeQuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三向切分的快速排序算法与快速排序算法的基本思想是差不多的主要针对的是数组中有很多</span></span><br><span class="line">    <span class="comment">//重复元素的情况，</span></span><br><span class="line">    <span class="keyword">int</span> lt,i,gt;<span class="comment">//首先定义三个指针，lo到lt-1都是比那个值v小的元素，lt到i-1都是和v相等的值，i到gt都是没有确定的值</span></span><br><span class="line">    <span class="comment">//gt+1到hi都是比v大的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi)&#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lt=lo;</span><br><span class="line">        <span class="keyword">int</span> v=a[lo];</span><br><span class="line">        gt=hi;</span><br><span class="line">        <span class="keyword">int</span> i=lo+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;gt) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;v)&#123;</span><br><span class="line">                ech(a,i,gt--);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;v)&#123;</span><br><span class="line">                ech(a,i++,lt++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">        sort(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ech</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem=a[i];</span><br><span class="line">            a[i]=a[j];</span><br><span class="line">            a[j]=tem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            a[i]=<span class="number">2</span>*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">10</span>;j&lt;<span class="number">20</span>;j++)&#123;</span><br><span class="line">            a[j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> ThreeQuickSort().sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/11/二叉查找树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/二叉查找树/" itemprop="url">二叉查找树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T13:39:28+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在进行查找操作时，可以用链表进行顺序查找或者用有序数组进行二分查找，这两种数据结构虽然很容易理解，但是缺点也比较明显，第一种方法只适用于小型问题，对于大型问题需要的时间比较长；第二种方法虽然实现了最优的效率和空间需求，并且能够进行有序性相关的操作，当时插入操作很慢（需要将插入点之后的数据向后移动一位）；所以接下来我们将介绍一种新的数据结构二叉查找树。</p>
<p>###二叉查找树的定义<br>二插查找树中的每个节点均有两个子节点（根节点除外），每个节点键值都比他的左子树中的任意一个节点键值大，比他的右子树中的任意一个节点键值小。 </p>
<p>####查找<br>二叉查找树中的查找操作是通过递归的思想实现的，通过不断的比较节点和待查找键值的大小来缩小查找的范围，具体的做法是：若当前节点键值大于待查找键值则在右子树中查找，反之则左子树中查找，知道当前节点为空或键值与待查找键值相等。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二叉查找树的查找操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> com=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span>(com&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(com&gt;<span class="number">0</span>) <span class="keyword">return</span> get(node.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;       </span><br><span class="line">插入</span><br><span class="line">如果二叉树中存在该键值，则更新他的值，反之则需要新建一个节点，这个操作的关键之处是需要更新以该节点为根节点的子树所包含的节点总数，我们还是通过递归来实现，具体的代码如下： </span><br><span class="line"><span class="comment">//二叉查找树的插入操作 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node node,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> com=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span>(com&lt;<span class="number">0</span>) node.right= put(node.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(com&gt;<span class="number">0</span>) node.left= put(node.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> node.value=value;</span><br><span class="line">        node.N=node.left.N+node.right.N+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p> 查找最大/小值、向上/下取整<br>查找最小值的方法很简单，二叉树中最左边叶子节点就是最小的那个 ，对应的最右边的那个节点的值是最大的，向上取整指的是大于等于他的最小值，向上取整指的是小于等于他的最大值。以向下取整为例，如果查询值小于节点的键值则递归的在左子树中查询，若等于则就是它了，反之则在右子树中进行查询，以右子节点为根节点进行查询，如果查询结果为null,则返回该节点，如果不为null,则直接返回右子树中的查询结果。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树的查找最大，最小的值的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) <span class="keyword">return</span> node.key;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> min(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二插查找树中向下取整函数的实现，即找到小于等于他的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            Key t=floor(node.right,key);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="keyword">null</span>) <span class="keyword">return</span> node.key;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)<span class="keyword">return</span> floor(node.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="排序和挑选"><a href="#排序和挑选" class="headerlink" title="排序和挑选"></a>排序和挑选</h4><p>排序（rank）操作就是查找小于该键值的节点数目，首先将key和根节点键值比较，如果比较小则递归到左子树中，相等则返回左子结点的N值。如果大则结果为size(node.Left)+1+rank(node.right)。选择也就是select（）函数思想是先比较index和左子节点的N值如果小于则递归到左子树中，相等则返回根节点的键值，大于则在右子树中查找index=index-size(node.left)-1;具体的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找某一个key在二叉查找树中的排名，即小于他的节点有多少个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span>(cmp==<span class="number">0</span>) <span class="keyword">return</span> node.left.N;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)  <span class="keyword">return</span> rank(node.left,key);</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> node.left.N+<span class="number">1</span>+rank(node.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据排名选择key,用函数select()表示,如果左子树的节点数目就大于k不断的在左子树找，反之则在右子树中找</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(Node node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left.N&gt;k) <span class="keyword">return</span> select(node.left,k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node.right.N&lt;k) <span class="keyword">return</span> select(node.right,k-node.left.N-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> node.key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>与其他操作相比，删除操作可以说是比较难的，因为每一个节点只有两个子节点，所以当删除一个节点后可能他的左右子树不能同时连接到他的父节点上，这有可能使得父节点有三个子节点。所以删除操作一般是通过四个步骤完成的（1）保存该节点的链接，（2）查找到右子树中的最小值min（3）使得右子树中删除最小值后的树成为min的又子树（4）删除节点的左子树成为min的左子树。具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除最大最小的键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">deletemin</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        root=deletemin(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deletemin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) <span class="keyword">return</span> node.right;</span><br><span class="line">        node.left=deletemin(node.left);</span><br><span class="line">        node.N=node.left.N+node.right.N+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除任意一个键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletekey</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        root=deletekey(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">deletekey</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp=node.key.compareTo(key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) node.left=deletekey(node.left,key);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) node.right=deletekey(node.right,key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left==<span class="keyword">null</span>) <span class="keyword">return</span> node.right;</span><br><span class="line">            <span class="keyword">if</span>(node.right==<span class="keyword">null</span>) <span class="keyword">return</span> node.left;</span><br><span class="line">            Node t=node;</span><br><span class="line">           <span class="comment">// node=min(node.right);</span></span><br><span class="line">            node.right=deletemin(node.right);</span><br><span class="line">            node.left=t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        node.N=node.left.N+node.right.N+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><p>二叉树的遍历方法主要有三种：前序遍历、中序遍历、后序遍历；前序遍历：根-左-右；中序遍历：左-根-右；后序遍历：左-右-根；具体的讲解可以参考二叉树遍历,例题讲解。中序遍历的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node x,Queue&lt;Key&gt;queue,Key lo,Key hi)</span> </span></span><br><span class="line"><span class="function"> <span class="title">if</span><span class="params">(x==<span class="keyword">null</span>)</span> return</span>;</span><br><span class="line"><span class="keyword">int</span> cmplo=lo.compareTo(x.key);</span><br><span class="line"><span class="keyword">int</span> cmphi=hi.compareTo(x.key);</span><br><span class="line"><span class="keyword">if</span>(cmplo&lt;<span class="number">0</span>)&#123;keys(x.left,queue,lo,hi);&#125;</span><br><span class="line"><span class="keyword">if</span>(cmplo&lt;=<span class="number">0</span>&amp;&amp;cmphi&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">queue.enqueue(x.key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cmphi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">keys(x.right,queue,lo,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/liuwuwu.jpg" alt="LiuWuWu">
            
              <p class="site-author-name" itemprop="name">LiuWuWu</p>
              <p class="site-description motion-element" itemprop="description">Tomorrow will be better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuWuWu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
