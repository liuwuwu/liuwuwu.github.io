<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Tomorrow will be better">
<meta property="og:type" content="website">
<meta property="og:title" content="Coder Paradise">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Coder Paradise">
<meta property="og:description" content="Tomorrow will be better">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder Paradise">
<meta name="twitter:description" content="Tomorrow will be better">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Coder Paradise</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coder Paradise</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">I am coding, I am happy.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/git上传项目/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/git上传项目/" itemprop="url">git上传项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T23:21:27+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近要上传自己的项目到github上面，为了防止以后忘记这些指令，特地写一篇博客，记录一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">//第一次上传时候使用；</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'web层xml文件的配置'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https:<span class="comment">//github.com/liuwuwu/project.git //获得远程连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master  <span class="comment">//获得远程仓库中的资源(不是第一次上传的话，必须要进行这一步)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master   <span class="comment">//上传项目文件</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/Mybatis学习笔记——Mybatis框架简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/Mybatis学习笔记——Mybatis框架简介/" itemprop="url">Mybatis学习笔记——Mybatis框架简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T15:33:27+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Mybatis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Mybatis框架的基础知识"><a href="#Mybatis框架的基础知识" class="headerlink" title="Mybatis框架的基础知识"></a>Mybatis框架的基础知识</h4><p>sqlMapConfig.xml:mybatis全局配置文件，配置数据源、事务等运行环境，配置映射文件(配置了sql语句)；<br>SqlSessionFactory:会话工厂，创建SqlSession；<br>SqlSession：会话，操作数据库(发出sql增、删、改、查)内部通过Executor操作数据库，mappedstatement(底层封装对象)，对数据库存储封装，包括sql语句，输入输出参数；</p>
<h4 id="和-的区别与联系"><a href="#和-的区别与联系" class="headerlink" title="#{}和\${}的区别与联系"></a>#{}和\${}的区别与联系</h4><p>$#{} 表示占位符，接收输入参数，类型可以是简单类型、pojo、hashmap；如果为简单类型，#{}中可以写成value或其他名称，通过ONGL读取对象中的属性值；<br>$${}表示一个拼接符号，会引起sql注入所以不建议使用\${}，接收输入参数，类型可以为简单类型、pojo、hashmap；如果为简单类型${}只能写为value;</p>
<h4 id="OGNL简介"><a href="#OGNL简介" class="headerlink" title="OGNL简介"></a>OGNL简介</h4><p>OGNL的全称是Object Graph Navigation Language(对象图导航语言)，它是一种强大的表达式语言，让你通过简单一致的表达式语法来读取和设置Java对象的属性值，调用对象的方法，遍历整个对象的结构图，实现字段类型转换等功能。<br>相对于其它的表达式语言，OGNL的功能更为强大，它提供了很多高级而必需的特性，例如强大的类型转换功能、静态或实例方法的执行、跨集合投影，以及动态lambda表达式定义等。<br>OGNL基础：OGNL表达式的计算都是围绕OGNL上下文来进行的，OGNL上下文实际上就是一个Map对象，由ognl.OgnlContext类(实现了java.util.Map接口)来表示。OGNL上下文可以包含一个或多个JavaBean对象，在这些对象中有一个是特殊的，这个对象就是上下文的根(root)对象。如果在写表达式的时候，没有指定使用上下文中的哪一个对象，那么根对象将被假定为表达式所依据的对象。在OGNL上下文中，只能有一个根对象，如果你访问根对象，那么在写表达式的时候，直接写对象的属性就可以了；否则，你需要使用“#key”前缀，例如表达式#namager.name。<br>OGNL表达式:OGNL表达式的基础单元就是导航链，通常简称为链(chain)。最简单的链由下列部分组成：<br>１、属性名：如name和manager.name；</p>
<p>２、方法调用：如manager.hashCode()，返回manager对象的散列码；</p>
<p>３、数组索引：如emals[0]，返回当前对象的邮件列表中的第一个邮件地址。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/Mybatis学习笔记——原生态JDBC的介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/Mybatis学习笔记——原生态JDBC的介绍/" itemprop="url">Mybatis学习笔记——原生态JDBC的介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T08:43:27+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mybatis学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Mybatis学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h4><p>1.加载数据库驱动；</p>
<p>2.获得数据库连接；</p>
<p>3.创建Statment对象，执行sql语句；</p>
<p>4.设置sql语句；</p>
<p>5.执行sql语句，得到结果集；</p>
<p>6.对结果集进行分析处理；</p>
<p>7.释放资源；</p>
<h4 id="原生态JDBC存在如下问题："><a href="#原生态JDBC存在如下问题：" class="headerlink" title="原生态JDBC存在如下问题："></a>原生态JDBC存在如下问题：</h4><p>1.每一个连接的在使用时候创建，不用的时候需要释放，如果使用频繁的话，频繁的建立和释放连接会浪费系统的资源，影响数据库的性能；<strong>使用数据库连接池解决</strong></p>
<p>2.将sql语句硬编码到Java代码中，修改sql语句需要重新编译，不利于系统的维护；<strong>将sql语句配置在xml配置文件中，即使sql文件变化也不需要重新编译</strong></p>
<p>3.向PrepareStatment中设置参数，会对占位符位置和参数值硬编码，不利于系统的维护；；<strong>将sql语句配置在xml配置文件中，即使sql文件变化也不需要重新编译</strong></p>
<p>4.从result中遍历结果集数据时存在硬编码，主要体现在将获取字段进行硬编码不利于系统维护。<strong>将查询结果集自动映射为Java对象</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/26/@AspectJ进阶/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/26/@AspectJ进阶/" itemprop="url">Spring读书笔记——@AspectJ进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-26T11:23:27+08:00">
                2018-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>@AspectJ可以使用切点函数定义切点，还可以使用逻辑运算符对切点进行符合运算得到复合切点，为了在切面中重用切点，还可以对切点进行命名，以便在其他地方引用定义过的切点。</p>
<h4 id="命名切点"><a href="#命名切点" class="headerlink" title="命名切点"></a>命名切点</h4><p>如果希望在其他地方重用一个切点，则可以通过@Pointcut注解及切面类方法对切点进行命名。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Test&#123;</span><br><span class="line"><span class="meta">@Pointcut</span>(within(com.smart.*))<span class="comment">//通过注解方法inpackage()对该切点命名，方法可视域修饰符为private，biao表明该命名切点只能在本切面类中使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inpackage</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* greetTo(..))"</span>)<span class="comment">//通过注解方法greeTo()对该切点进行命名，方法可视域修饰符为protected,表明该命名切点只能在本切面类中使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="绑定连接点方法入参"><a href="#绑定连接点方法入参" class="headerlink" title="绑定连接点方法入参"></a>绑定连接点方法入参</h4><p>之前介绍的切点函数args()、this()等除了可以指定类名外，还可以指定参数名，将目标对象连接点上的方法入参绑定到增强方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"target(com.smart.NativeWaiter)&amp;&amp;args(name,num)"</span>)<span class="comment">//绑定方法入参，首先args(name,num)根据增强方法入参找到name和num对应的类型，得到真实的切点表达式，接着在该增强方法织入到目标连接点时，增强方法可以通过num,name访问到连接点入参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindargs</span><span class="params">(<span class="keyword">int</span> num,String name)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>切点入参匹配是这样的：首先args()根据参数名称在增强方法中找到名称相同的入参并获得对应的类型这样就得到了匹配连接点方法的入参类型。接着连接点方法入参类型所在的位置则由参数名在args()函数中声明的位置决定。</p>
<h4 id="绑定代理对象"><a href="#绑定代理对象" class="headerlink" title="绑定代理对象"></a>绑定代理对象</h4><p>使用this()或者target()函数可以绑定被代理对象的实例，在通过类实例名绑定对象时，依然具有原来连接点匹配的功能，只不过类名是通过增强方法中同名的入参的类型间接决定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"this(waiter)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Waiter waiter)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="绑定返回值"><a href="#绑定返回值" class="headerlink" title="绑定返回值"></a>绑定返回值</h4><p>在后置增强中可以使用returning绑定连接点方法的返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"target(com.smart.NativeWaiter)"</span>,returning=<span class="string">"retVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> retVal)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="绑定抛出的异常"><a href="#绑定抛出的异常" class="headerlink" title="绑定抛出的异常"></a>绑定抛出的异常</h4><p>和通过切点函数绑定连接点信息不同，连接点抛出的异常必须要使用AfterThrowing注解的throwing成员进行绑定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"target(com.smart.NativeWaiter)"</span>,throwing=<span class="string">"aie"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(IllegalArgumentException aie)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/25/Spring读书笔记——基于@AspectJ的AOP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/25/Spring读书笔记——基于@AspectJ的AOP/" itemprop="url">Spring读书笔记——基于@AspectJ的AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-25T19:31:27+08:00">
                2018-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用前的准备"><a href="#使用前的准备" class="headerlink" title="使用前的准备"></a>使用前的准备</h3><p>在使用@AspectJ之前，首先必须保证使用的是java5.0及以上版本。spring在处理@AspectJ注解表达式时需要将spring的asm模块添加到类路径中。asm是轻量级的字节码处理框架，因为Java的反射机制无法获取入参名，spring就利用sam处理@AspectJ中所描述的方法入参名。此外spring采用@AspectJ提供的@AspectJ注解类及相应的解析库，需要在pom.xml文件中添加aspectj.weaver和aspectj.tools类包的依赖。下面是一个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AspectJ</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreGretingAspect</span></span>&#123;</span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* greetTo(..))"</span>)<span class="comment">//定义切点和增强类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGreting</span><span class="params">()</span></span>&#123;<span class="comment">//增强的横切逻辑</span></span><br><span class="line">System.out.println(<span class="string">"尊敬的顾客您好"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过配置使用-AspectJ切面"><a href="#通过配置使用-AspectJ切面" class="headerlink" title="通过配置使用@AspectJ切面"></a>通过配置使用@AspectJ切面</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标bean</span></span><br><span class="line">&lt;bean id=<span class="string">"waiter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.NativeWaiter"</span>/&gt;</span><br><span class="line"><span class="comment">//使用了@AspectJ注解的切面类</span></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.aspectj.example.PreGreetingAspect"</span>/&gt;</span><br><span class="line"><span class="comment">//自动代理创建器，自动将@AspectJ注解切面类织入到目标bean中</span></span><br><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>如果使用基于schema的aop命名空间进行配置，就更加简单了。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"waiter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.NativeWaiter"</span>/&gt;</span><br><span class="line">&lt;bean <span class="string">"com.smart.aspectj.example.PreGreetingAspect"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>首先在配置文件处引入aop的命名空间，接着通过aop命名空间的<a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a>自动为spring容器中那些匹配@AspectJ切面的Bean创建代理完成切面的织入工作。</p>
<h4 id="切点表达式函数"><a href="#切点表达式函数" class="headerlink" title="切点表达式函数"></a>切点表达式函数</h4><p>为了描述方便将execution(<em> greetTo(..))中的execution()称为函数，匹配串</em> greetTo(..)称为入参。</p>
<h5 id="函数中使用通配符"><a href="#函数中使用通配符" class="headerlink" title="函数中使用通配符"></a>函数中使用通配符</h5><p>@AspectJ中支持3种通配符：<br><strong>*</strong>：匹配任意字符，但它只能匹配上下文中的一个元素；<br><strong>..</strong>：匹配任意字符，可以匹配上下文中的多个元素，但是在表示类时，必须和*联合使用，而在表示入参时可以单独使用；<br><strong>+</strong>：表示按类型匹配指定类的所有类型，必须跟在类名后面，继承或者扩展指定类的所有类，同时还包括指定类本身。</p>
<h4 id="不同的增强类型"><a href="#不同的增强类型" class="headerlink" title="不同的增强类型"></a>不同的增强类型</h4><p> @AspectJ为各种增强提供了不同的注解类：<br> 1.@Before<br> 前置增强，相当于BeforeAdvice。拥有两个成员：value(用于定义切点)。argNames:由于无法通过Java的反射机制获取方法的入参名，所以如果在编译阶段未启用调试信息，或者需要在运行期解析切点，就必须通过这个成员指定注解所标注的增强方法的参数名，多个参数用，号分隔。<br> 2.@AfterReturning<br> 后置增强，相当于AfterReturningAdvice。该注解类拥有4个成员：value(定义切点)，pointcut:表示切点的信息。如果显示指定pointcut的值，那么他将覆盖value的值。returning(将目标对象的方法返回值绑定给增强的方法)。args(如前所述)<br> 3.@Around<br> 环绕增强，相当于MentodInterceptor。Around注解类拥有两个成员：value(定义切点)，argsNames(如前所述)。<br> 4.@AfterThrowing<br>抛出增强，相当于ThrowsAdvice。该类注解共有4个成员:value(定义切点)，pointcut(如前所述)，throwing(将抛出的异常绑定到增强方法中)，args(如前所述)。<br>5.@After<br>Final增强，不管是抛出增强还是正常退出，该增强都会得到执行，该增强没有对应的接口，可以把他看成AfterReturningAdvice和ThrowsAdvice的混合物。一般用于释放资源。该注解类拥有两个成员(value和argsName)<br>6.@DeclareParents<br>引介增强，相当于IntroductionInterceptor。拥有两个成员value(定义切点，他表示在哪个目标类上添加引介增强)，defauleImpl(默认的接口实现类)。</p>
<h4 id="切点函数种类"><a href="#切点函数种类" class="headerlink" title="切点函数种类"></a>切点函数种类</h4><p>1.@annotation表示标注了某个注解的所有方法例子如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="meta">@annotation</span>(com.smart.anno.NeedTest))<span class="comment">//假设Waiter的greet方法标注了@NeedTest注解，spring会将切面注入到该方法中</span></span><br></pre></td></tr></table></figure></p>
<p>2.execution()是最常用的切点函数，语法如下：execution(&lt;修饰符模式&gt;？&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;&lt;异常模式&gt;?)除了返回类型、方法名、参数等模式外其它项都是可选的。<br>在类名模式串中“.<em>”表示包下的所有类，而“..</em>”表示包、子孙包下的所有类。通过方法入参定义切点时，可以使用“*”和“..”通配符，前者表示任意类型的参数，后者表示任意类型的参数且参数的个数不限。<br>3.args()和@args():前者接收一个类名，表示目标类方法入参对象是指定类(包含子类时)，切点匹配如args(com.smart.Waiter);后者接收一个注解类的类名，当方法的运行时入参对象标注了指定的注解时，匹配切点。例子见书p287页。<br>4.@within(),通过类匹配模式声明切点，该函数定义的连接点是针对目标类而言的，而非针对运行期对象而言，与execution函数不同的是该函数指定的最小范围只能是类。which(com.smart.A)匹配A中的所有方法。<br>5.@target()和@Within(),@target(M)匹配任意标注了@M的目标类，@Within()匹配标注了@M的类及子孙类。<strong>@target()、@Within()和@annotation针对的都是目标类，而非运行时的引用类型而言，所以如果在接口上标注实现该接口的类都不会匹配该切点</strong><br>6.target和this,前者通过判断目标类是否按类型匹配指定类来决定连接点是否匹配，而this通过判断代理类是否按类型匹配指定类来决定是否和切点匹配。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/24/Spring读书笔记——AOP的基础/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/24/Spring读书笔记——AOP的基础/" itemprop="url">Spring读书笔记——AOP的基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-24T15:54:27+08:00">
                2018-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AOP（Aspect Oriented Programing）面向切面编程，他能够将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立的模块中，将横切逻辑与业务逻辑分离。按照软件重构的思想，如果多个类中出现了相同的代码，则可以定义一个父类，将这些相同的代码定义到父类中，但是在有些情况下重复的代码位于方法中(如性能监控代码)，我们无法通过定义父类使用继承体系进行纵向的抽取，只能通过AOP进行横向抽取。</p>
<h4 id="AOP中的术语"><a href="#AOP中的术语" class="headerlink" title="AOP中的术语"></a>AOP中的术语</h4><p>1.连接点(Joinpoint)：spring仅支持方法的连接点，即进能在方法调用前，方法调用后，方法异常抛出时，以及方法调用前后植入增强，spring中连接点可以理解为方法。它由两个信息确定：方法表示的执行点和相对位置表示的方位。<br>2.切点(Pointcut)：AOP通过切点定位特定的连接点，可以将连接点比作数据库中的记录，切点当作数据库查询的条件，切点和连接点不是一对一的关系一个切点可以匹配多个连接点。<br>3.增强(Advice):在spring中增强除了用于描述一段程序的代码外，还拥有另外一个和连接点相关的信息，这便是执行点的方位信息。<br>4.目标对象(Target) 增强逻辑的植入目标。<br>5.织入(waving) 织入是将增强添加到目标类的具体的连接点上的过程，根据不同的实现技术，AOP有三种织入方式：<br>（1）编译期织入，要求使用特殊的Java编译器；<br>（2）类装载期织入，要求使用特殊的类装载器；<br>（3）动态代理织入，在运行期为目标类添加增强，有两种方式JDK的动态代理和CGLib的动态代理。<br>6.代理：一个类被AOP织入增强后，就产生了一个结果类，他是融合了原类和增强逻辑的代理。<br>7.切面：切面由切点和增强组成，它既包含横切逻辑的定义也包含连接点的定义。SpringAOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面指定的连接点中。<br><strong>增强的类型</strong>：AOP联盟一共定义了5种增强类型分别为前置增强、后置增强、环绕增强、异常抛出增强、引介增强。</p>
<h4 id="AOP切面"><a href="#AOP切面" class="headerlink" title="AOP切面"></a>AOP切面</h4><p>增强提供了连接点的方位信息，如织入到方法前、方法后等。而切点进一步描述了织入哪些类的哪些方法上，spring通过Pointcut接口描述了切点。PointCut由classFilter和MethodMatcher构成，分别进行类和方法的定位。spring支持两种方法匹配器，静态方法匹配器和动态方法匹配器。静态方法匹配器仅对方法的签名(包含方法名和入参类型及顺序)进行匹配；而动态匹配因为每次调用的方法的入参可能都不一样，所以每次调用都必须进行判断。</p>
<h5 id="切面的类型"><a href="#切面的类型" class="headerlink" title="切面的类型"></a>切面的类型</h5><p><strong>Advisor</strong>:代表一般的切面，仅仅包含一个Advice，因为Advice包含了横切代码和连接点信息，所以它本身就是一个切面，只不过它匹配目标类的所有方法。<br><strong>PointcutAdvisor</strong>:代表具有切点的切面，包含Advice和Pointcut两个类，这样就可以通过类、方法名及方法方位等信息进行定义切面的连接点。<br><strong>IntroductionAdvisor</strong>:代表引介切面。</p>
<h4 id="自动创建代理"><a href="#自动创建代理" class="headerlink" title="自动创建代理"></a>自动创建代理</h4><p>spring提供了自动代理创建机制，让容器自动生成代理，把工作人员从繁琐的配置工作中解放出来，在内部spring是使用BeanPostProcessor自动完成这项工作的。<br>这些基于BeanPostProcessor的自动代理创建器的实现类，将根据一些规则在容器实例化bean时为匹配的bean生成代理实例。这些代理创建器可以分为3类：<br>1.基于Bean配置名规则的自动代理创建器：允许为一组特定的配置名的bean创建代理实例的自动代理创建器，实现类为BeanNameAutoProxyCreator;<br>2.基于Advisor匹配机制的自动代理创建器：它会对容器中所有的Advisor进行扫描，自动将这些切面运用到匹配的bean中，实现类为DefaultAdvisorAutoProxyCreator。<br>3.基于Bean中AspectJ注解标签的自动代理创建器：为包含AspectJ注解的bean自动创建代理实例，实现类为AnnotationAwareAspectJAdvisorAutoProxyCreator。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Spring读书笔记——在IOC容器中装配Bean—基于注解的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Spring读书笔记——在IOC容器中装配Bean—基于注解的配置/" itemprop="url">Spring读书笔记——在IOC容器中装配Bean—基于注解的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T23:39:41+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不管是XML还是注解，他们都是表达Bean定义的载体，其实质都是为了Spring提供Bean的定义信息，在表现形式上都是将XML定义的内容通过注解进行描述，我们知道spring容器成功启动的三大要件分别为Bean的定义信息、Bean的实现类、和spring容器本身。如果采用XML的配置方式，bean的定义信息和实现类是分离的，而如果使用注解进行配置，则bean的定义信息通过在bean的实现类上进行标注注解实现。</p>
<h4 id="通过注解定义一个Bean"><a href="#通过注解定义一个Bean" class="headerlink" title="通过注解定义一个Bean"></a>通过注解定义一个Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@component</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">UserDao</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@component注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring自动将POJO转换为容器管理的bean。除了@component之外Spring还提供了3个功能基本和@compoent等效的注解：<br>@Respository:用于对Dao的实现类进行标注；<br>@Service： 用于对service的实现类进行标注；<br>@Controller:用于对Controller实现类进行标注；</p>
<h4 id="扫描注解定义的Bean"><a href="#扫描注解定义的Bean" class="headerlink" title="扫描注解定义的Bean"></a>扫描注解定义的Bean</h4><p>spring提供了一个context命名空间，它提供了通过扫描类包以应用注解定义的方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描类包以应用注解定义的Bean</span></span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.smart.anno"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过context命名空间的component-scan的base-package属性指定一个需要扫描的基类包，spring会扫描这个基类中的所有类，并从类的注解信息中获得Bean的定义信息。如果希望扫描特定的类可以使用resource-pattern属性过滤数出特定的类。</p>
<h4 id="自动装配bean"><a href="#自动装配bean" class="headerlink" title="自动装配bean"></a>自动装配bean</h4><p>spring使用@Autowired注解实现Bean的依赖注入，下面举一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">LoggonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="keyword">private</span> LogDao logdao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般来说，如果spring容器中没有一个和标注变量类型匹配的Bean，那么spring启动时将报NoSuchBeanDefinitionException异常,如果希望即使找不到也不抛出异常，可以使用@Autowire（required=false）进行标注。<br>我们还可以使用@Qualifier指定注入Bean的名称。如果容器中有一个以上的匹配时，则可以通过@Qualifier注解限定Bean的名称<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">LoggonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="keyword">private</span> LogDao logdao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了上面介绍的对类的成员变量进行标注外，@Autowire还可以对类的方法进行标注，表示对入参进行自动装配。同样我们也可以通过@Qualifier指定bean的名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@service</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">LoggonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(UserDao userDao)</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有多个参数的时候</span></span><br><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(@Qualifier(<span class="string">"userDao"</span>)</span> UserDao userDao，LogDao logdao))</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="对延时依赖注入的支持"><a href="#对延时依赖注入的支持" class="headerlink" title="对延时依赖注入的支持"></a>对延时依赖注入的支持</h5><p>spring支持延时依赖注入，即在spring容器启动的时候，对于bean上面标注了@Lazy和@Autowire注解的属性，不会立即注入属性值，而是延时到调用此属性的时候才会注入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@service</span></span><br><span class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">LoggonService</span></span>&#123;</span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Autowire</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(UserDao userDao)</span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对bean实施延时依赖注入，要注意@Lazy必须要同时标注在属性和目标bean上如上例所示，缺一不可</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/Spring读书笔记——在IOC容器中装配Bean—基于XML的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/Spring读书笔记——在IOC容器中装配Bean—基于XML的配置/" itemprop="url">Spring读书笔记——在IOC容器中装配Bean—基于XML的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-23T21:02:01+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用spring的各项神奇而丰富的功能之前必须要装配好bean，并且建立好他们之间的关系。</p>
<h2 id="基于XML的配置"><a href="#基于XML的配置" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>spring主要支持三种注入方式：属性注入、构造方法注入、工厂方法注入；</p>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><p><strong>定义</strong>：属性注入是指通过setXxx()方法注入bean的属性值或者依赖对象；<br><strong>优点</strong>：具有可选择性和灵活性高的优点；<br><strong>要求</strong>：bean必须要提供一个默认的构造函数，并为需要注入的属性提供对应的setter方法。Spring通过默认的构造函数实例化bean对象，通过反射机制然后调用setter方法注入属性值。<br>JavaBean的属性命名规范：xxx属性对应setXxx()方法。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.ditype</span><br><span class="line"><span class="comment">//属性注入的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String brand;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.brand=brand;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置文件中的内容如下：</span></span><br><span class="line">   &lt;bean id=<span class="string">"car"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"brand"</span> value=<span class="string">"红旗71"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要指出的是，spring中只会检查Bean中是否有对应的Setter方法，至于Bean中是否有对应的成员变更则不做要求，举个例子上面中class类中不一定要拥有brand成员变量。</p>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>构造函数注入保证了一些必要的属性在Bean实例化时就得到设置，确保Bean在实例化后就可以使用。</p>
<h5 id="构造函数注入的参数匹配"><a href="#构造函数注入的参数匹配" class="headerlink" title="构造函数注入的参数匹配"></a>构造函数注入的参数匹配</h5><p>构造函数注入中可以按照如下方式匹配入参：按类型匹配入参、按索引匹配入参、联合使用类型和索引匹配入参、通过自身类型反射匹配入参。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照类型匹配入参</span></span><br><span class="line">&lt;bean id=<span class="string">"car"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">  &lt;constructor-arg type=<span class="string">"java.lang.String"</span> value=<span class="string">"红旗72"</span>&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> <span class="comment">//按照索引匹配,构造函数的第一个索引为0</span></span><br><span class="line"> &lt;bean id=<span class="string">"car"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">  &lt;constructor-arg index=<span class="string">"0"</span> value=<span class="string">"红旗72"</span>&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> <span class="comment">//联合使用索引和类型进行匹配</span></span><br><span class="line"> &lt;bean id=<span class="string">"car"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">  &lt;constructor-arg index=<span class="string">"0"</span>,type=<span class="string">"java.lang.String"</span> value=<span class="string">"红旗72"</span>&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> <span class="comment">//通过自身类型反射匹配入参</span></span><br><span class="line"> &lt;bean id=<span class="string">"car"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">  &lt;constructor-arg value=<span class="string">"Jhon"</span>&gt;</span><br><span class="line">  &lt;constructor-arg ref bean=<span class="string">"car"</span>&gt;</span><br><span class="line">   &lt;constructor-arg ref bean=<span class="string">"office"</span>&gt;</span><br><span class="line"> &lt;/bean&gt;</span><br><span class="line"> &lt;bean id=<span class="string">"car"</span> calss=<span class="string">"com.smart.ditype.Car"</span> /&gt;</span><br><span class="line">  &lt;bean id=<span class="string">"office"</span> calss=<span class="string">"com.smart.ditype.Office"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过自身类型反射匹配入参要求构造函数的入参类型是可以分辨的(非基础类型且入参类型各异)，由于Java的反射机制可以获取构造函数的入参类型，即使构造函数注入的配置不提供类型和索引信息，spring依旧可以正确的完成构造函数的注入工作。</p>
<h5 id="构造函数注入中的循环依赖问题"><a href="#构造函数注入中的循环依赖问题" class="headerlink" title="构造函数注入中的循环依赖问题"></a>构造函数注入中的循环依赖问题</h5><p>spring容器对构造函数配置的bean进行实例化有一个前提，即bean构造函数的入参引用的对象必须准备就绪，由于这个机制的限制，如果两个bean都采用构造函数注入，而且都通过构造函数入参引用对方，就会发生类似死锁的循环依赖问题。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">     <span class="comment">//构造函数依赖一个boss实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand,Boss boss)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand=brand;</span><br><span class="line">        <span class="keyword">this</span>.boss=boss;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造函数依赖一个car实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(String name,Car car)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">  <span class="keyword">this</span>.car=car;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置文件为</span></span><br><span class="line">&lt;bean id=<span class="string">"car"</span> calss=<span class="string">"com.smart.ditype.Car"</span>&gt;</span><br><span class="line">&lt;Constructor-arg index=<span class="string">"0"</span> value=<span class="string">"红旗"</span>&gt;</span><br><span class="line">&lt;Constructor-arg index=<span class="string">"1"</span> ref=<span class="string">"boss"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="comment">//----------------------------</span></span><br><span class="line">&lt;bean id=<span class="string">"boss"</span> calss=<span class="string">"com.smart.ditype.Boss"</span>&gt;</span><br><span class="line">&lt;Constructor-arg index=<span class="string">"0"</span> value=<span class="string">"John"</span>&gt;</span><br><span class="line">&lt;Constructor-arg index=<span class="string">"1"</span> ref=<span class="string">"car"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>解决方法：只需要修改Bean的代码，将构造函数注入方式改为属性注入。</p>
<h4 id="工厂方法注入"><a href="#工厂方法注入" class="headerlink" title="工厂方法注入"></a>工厂方法注入</h4><p>在一些遗留的系统或者第三方类库中，我们还会遇到工厂方法，这时可以使用spring工厂方法注入的方式进行配置。</p>
<h4 id="非静态工厂方法"><a href="#非静态工厂方法" class="headerlink" title="非静态工厂方法"></a>非静态工厂方法</h4><p>有些工厂方法是非静态的，必须实例化工厂类后才能够调用工厂方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.ditype</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="comment">//创建car的工厂方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Car car=<span class="keyword">new</span> Car();</span><br><span class="line">       car.setBrand(<span class="string">""</span>);</span><br><span class="line">       <span class="keyword">return</span> car</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置文件如下：</span></span><br><span class="line">&lt;bean id=<span class="string">"carFactory"</span> calss=<span class="string">"com.smart.ditype.CarFactory"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"car5"</span> factory-bean=<span class="string">"carFactory"</span> factory-method=<span class="string">"createcar"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.smart.ditype</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line"><span class="comment">//创建car的工厂方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">   ....</span><br><span class="line">   <span class="comment">// 配置文件如下：</span></span><br><span class="line">&lt;bean id=<span class="string">"car5"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.smart.ditype.CarFactory"</span> factory-method=<span class="string">"createcar"</span>/&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/BeanFactory和ApplicationContext/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/BeanFactory和ApplicationContext/" itemprop="url">BeanFactory和ApplicationContext</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T23:16:39+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>BeanFactory是spring容器中最核心的接口，他提供了高级的IOC配置，使得管理不同的Java对象成为可能。应用上下文建立在BeanFactory的基础之上，提供了很多面向应用的功能。对于两者的用途我们可以进行简单的划分：BeanFactory是spring的基础，面向spring本身。而ApplicationContext是面向使用spring的开发者，几乎所有的场合都可以直接使用ApplicationContext而非BeanFactory。</p>
<h3 id="BeanFactory和ApplicationContext的差异"><a href="#BeanFactory和ApplicationContext的差异" class="headerlink" title="BeanFactory和ApplicationContext的差异"></a>BeanFactory和ApplicationContext的差异</h3><p>1.bean的初始化时机不同：BeanFactory在初始化容器时并没有实例化bean,只有在第一次访问某个bean时候才会实例化目标bean；<br>2.注册BeanPostProcessor、InstantiationAwareBeanPostProcessor、BeanFactoryPostProcessor的方式不同。ApplicationContext会通过反射机制自动的识别配置文件中的BeanPostProcessor、InstantiationAwareBeanPostProcessor、BeanFactoryPostProcessor并将他们自动的注册到应用上下文中，而BeanFactory需要在代码中通过手工调用addBeanPostProcessor()方法进行注册。</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><h4 id="BeanFactory中Bean的生命周期"><a href="#BeanFactory中Bean的生命周期" class="headerlink" title="BeanFactory中Bean的生命周期"></a>BeanFactory中Bean的生命周期</h4><p>1.当调用getBean()方法向容器请求一个Bean时，如果容器注册了InstantiationAwareBeanPostProcessor接口，则在实例化Bean之前就postProcessBeforeInstantiation()方法；</p>
<p>2.根据配置情况调用Bean的构造函数或者工厂方法实例化Bean；</p>
<p>3.如果容器实现了InstantiationAwareBeanPostProcessor接口，那么在实例化Bean之后，将调用该接口的postProcessAfterInstantiation()方法,可以在这里对Bean进行处理；</p>
<p>4.如果Bean配置了属性信息，在将配置值设置到Bean对应的属性之前会先调用InstantiationAwareBeanPostProcessor接口的postProcessPropetryValues()方法；</p>
<p>5.调用Bean的set方法设置对应的属性值；</p>
<p>6.如果Bean实现了BeanNameAware接口，将调用该接口的setBeanName()方法，设置Bean的名字；</p>
<p>7.如果Bean实现了BeanFactoryAware接口,调用该接口的setBeanFactory()方法,设置对应的BeanFactory；</p>
<p>8.如果BeanFactory装配了BeanPostProcessor后处理器，则将调用BeanPostProcessor的postProcessBeforeInitialization(Object bean,String beanName)方法对Bean进行加工操作，<strong>BeanPostProcessor</strong>在Spring框架中占有十分重要的地位，为容器提供了后续加工处理的切入点，如动态代理，AOP等都是通过他实现的；</p>
<p>9.如果Bean实现了Initiali接口，则调用该接口的afterPropertiesSet()方法；</p>
<p>10.执行配置文件中的init-method方法；<br>11.执行BeanPostProcessor接口的postProcessAfterInitialization(Object bean,String beanName)方法进行加工操作;</p>
<p>12.如果是单例Bean则放入spring容器的缓冲池中，不是则返回给调用者，调用者负责后续生命周期的管理；</p>
<p>13.对于单例Bean,容器关闭时，如果Bean实现了DisposableBean接口,则调用destory()方法进行释放资源和记录日志的操作；</p>
<p>14.调用destory-method中指定的Bean销毁方法；</p>
<h4 id="ApplicationContext中Bean的生命周期"><a href="#ApplicationContext中Bean的生命周期" class="headerlink" title="ApplicationContext中Bean的生命周期"></a>ApplicationContext中Bean的生命周期</h4><p>Bean在应用上下文中的生命周期和BeanFactory中的类似，不同主要体现在两点：<br>1.如果Bean实现了ApplicationContextAware接口，则会在上述8步和9步之间执行setApplicationContext()方法；</p>
<p>2.此外如果在配置文件中声明了工厂后处理器接口BeanFactoryPostProcessor，则应用上下文在装载配置文件后、初始化Bean实例之前会调用这些BeanFactoryPostProcessor对配置信息进行加工处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/21/Spring读书笔记——IOC容器概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiuWuWu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/liuwuwu.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coder Paradise">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/21/Spring读书笔记——IOC容器概述/" itemprop="url">Spring读书笔记——IOC容器概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-21T15:02:11+08:00">
                2018-12-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Spring读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IOC(Inverse of Control,控制反转)是Spring容器中的一个内核，AOP、声明式事务管理在此基础上发展而来。控制指的是调用类对某一接口实现类的选择权，反转是指该接口的实现类的控制权不由调用类决定，由第三方容器决定，也就是spring容器通过Bean的配置进行控制。</p>
<h3 id="IOC的类型"><a href="#IOC的类型" class="headerlink" title="IOC的类型"></a>IOC的类型</h3><p>IOC主要包含三种类型：构造函数注入、属性注入、接口注入，接下来我们将以书上的例子详细讲解一下这三种注入方式。</p>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>我们假设这样一种场景，张艺谋导演想和刘德华合作拍一部大型的电影《墨攻》，其中有一个场景就是守门人大喊：“楼下何人”，隔离答道：“墨者隔离”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始代码，演员和剧本高度耦合，不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoAttack</span></span>&#123;</span><br><span class="line"><span class="comment">//演员直接侵入剧本，和剧本高度耦合</span></span><br><span class="line">LiuDeHua ldh=<span class="keyword">new</span> LiuDeHua();</span><br><span class="line">ldh.responseAsk(<span class="string">"墨者隔离"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------通过构造函数注入进行改善---------------</span></span><br><span class="line"><span class="keyword">public</span> MoAcctack&#123;</span><br><span class="line"><span class="keyword">private</span> Gili geli;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MoAcctack</span><span class="params">(Gili geli)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.gili=geli;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">  geli.responseAsk(<span class="string">"墨者隔离"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//指定具体的演员</span></span><br><span class="line">  Geli geli=<span class="keyword">new</span> LiuDeHua();</span><br><span class="line">  <span class="comment">//将演员注入到剧本中</span></span><br><span class="line">  MoAcctack mo=<span class="keyword">new</span> MoAcctack(geli);</span><br><span class="line">  mo.cityGateAsk();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现此时剧本和演员是实现了解耦，演员的挑选工作交给了导演。</p>
<h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MoAcctack&#123;</span><br><span class="line"><span class="keyword">private</span> Gili geli;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGili</span><span class="params">(Gili geli)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.gili=geli;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">  geli.responseAsk(<span class="string">"墨者隔离"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//指定具体的演员</span></span><br><span class="line">  Geli geli=<span class="keyword">new</span> LiuDeHua();</span><br><span class="line">  <span class="comment">//将演员注入到剧本中</span></span><br><span class="line">  MoAcctack mo=<span class="keyword">new</span> MoAcctack();</span><br><span class="line">  mo.setGili(geli);</span><br><span class="line">  mo.cityGateAsk();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与构造函数注入不同的是，属性注入是通过set方法进行注入的。</p>
<h4 id="接口注入"><a href="#接口注入" class="headerlink" title="接口注入"></a>接口注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Actorarrange</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Gili geli;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(Geli geli)</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//实现这个接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class MoAcctack implements Actorarrange</span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectGeli</span><span class="params">(Geli geli)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gili=geli;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cityGateAsk</span><span class="params">()</span></span>&#123;</span><br><span class="line">       geli.responseAsk(<span class="string">"墨者隔离"</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//指定具体的演员</span></span><br><span class="line">  Geli geli=<span class="keyword">new</span> LiuDeHua();</span><br><span class="line">  <span class="comment">//将演员注入到剧本中</span></span><br><span class="line">  MoAcctack mo=<span class="keyword">new</span> MoAcctack();</span><br><span class="line">  mo.injectGili(geli);</span><br><span class="line">  mo.cityGateAsk();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="三种注入方式的比较"><a href="#三种注入方式的比较" class="headerlink" title="三种注入方式的比较"></a>三种注入方式的比较</h4><p>构造函数注入的特点是在对象初始化结束后就完成了注入工作，就是说我一旦说开始拍电影，我的演员就要一直存在，这种方式不是很灵活，因为可能有些场景我们不需要该演员的参与。这样的话造成了资源的浪费。属性注入则不同，什么时候需要，什么时候注入。这种注入方式的前提是调用的对象一定要有默认的构造器，否则会报错。接口注入方式和属性注入很相似，但是需要额外的接口，这在无形之中就增加了类的数目。所以一般不使用。<br><strong>与例子中的导演的功能类似spring容器就是通过配置文件或者注释来描述类和类之间的依赖关系，并完成对象的初始化和依赖注入的</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/liuwuwu.jpg" alt="LiuWuWu">
            
              <p class="site-author-name" itemprop="name">LiuWuWu</p>
              <p class="site-description motion-element" itemprop="description">Tomorrow will be better</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiuWuWu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
